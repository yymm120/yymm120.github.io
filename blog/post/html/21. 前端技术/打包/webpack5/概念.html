<!DOCTYPE html><html lang="en"><head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Allen Dev</title>
    <link href="/bundle.css" rel="stylesheet" type="text/css">
  </head>
  <body>
    <div id="app">
      <div id="left">
        <div id="left-section1">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <path fill="currentColor" d="M3 8V7h17v1zm17 4v1H3v-1zM3 17h17v1H3z"></path>
          </svg>
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path fill-rule="evenodd" clip-rule="evenodd" d="M10 7H18C18.2652 7 18.5196 7.10536 18.7071 7.29289C18.8946 7.48043 19 7.73478 19 8V16C19 16.2652 18.8946 16.5196 18.7071 16.7071C18.5196 16.8946 18.2652 17 18 17H10V7ZM9 7H6C5.73478 7 5.48043 7.10536 5.29289 7.29289C5.10536 7.48043 5 7.73478 5 8V16C5 16.2652 5.10536 16.5196 5.29289 16.7071C5.48043 16.8946 5.73478 17 6 17H9V7ZM4 8C4 7.46957 4.21071 6.96086 4.58579 6.58579C4.96086 6.21071 5.46957 6 6 6H18C18.5304 6 19.0391 6.21071 19.4142 6.58579C19.7893 6.96086 20 7.46957 20 8V16C20 16.5304 19.7893 17.0391 19.4142 17.4142C19.0391 17.7893 18.5304 18 18 18H6C5.46957 18 4.96086 17.7893 4.58579 17.4142C4.21071 17.0391 4 16.5304 4 16V8Z" fill="white"></path>
          </svg>
        </div>
        <div id="left-section2">
          <h4>鸿蒙文档v12 笔记</h4>
          <span>最近更新: 2024.11.19</span>
        </div>
        <div id="left-section3">
          <div class="search">
            <input value="" placeholder="Search">
            <button>
              <svg width="24" height="23" viewBox="0 0 24 23" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M15 10.5C15 11.091 14.8836 11.6761 14.6574 12.2221C14.4313 12.768 14.0998 13.2641 13.682 13.682C13.2641 14.0999 12.768 14.4313 12.2221 14.6575C11.6761 14.8836 11.0909 15 10.5 15C9.90903 15 9.32387 14.8836 8.7779 14.6575C8.23194 14.4313 7.73586 14.0999 7.318 13.682C6.90013 13.2641 6.56867 12.768 6.34252 12.2221C6.11637 11.6761 5.99998 11.091 5.99998 10.5C5.99998 9.30653 6.47408 8.16194 7.318 7.31803C8.16191 6.47411 9.3065 6.00001 10.5 6.00001C11.6935 6.00001 12.838 6.47411 13.682 7.31803C14.5259 8.16194 15 9.30653 15 10.5ZM14.044 14.706C12.9595 15.6198 11.564 16.0794 10.1487 15.9888C8.7335 15.8982 7.40794 15.2645 6.44879 14.2199C5.48964 13.1754 4.97104 11.8007 5.00125 10.3829C5.03146 8.96506 5.60814 7.61372 6.61091 6.61094C7.61368 5.60817 8.96503 5.03149 10.3828 5.00128C11.8007 4.97107 13.1753 5.48967 14.2199 6.44882C15.2645 7.40797 15.8982 8.73353 15.9888 10.1488C16.0793 11.564 15.6198 12.9595 14.706 14.044C14.7611 14.0688 14.8112 14.1033 14.854 14.146L17.854 17.146C17.9017 17.1921 17.9398 17.2473 17.966 17.3083C17.9922 17.3693 18.006 17.4349 18.0066 17.5013C18.0072 17.5677 17.9945 17.6335 17.9694 17.695C17.9442 17.7564 17.9071 17.8123 17.8602 17.8592C17.8132 17.9062 17.7574 17.9433 17.696 17.9684C17.6345 17.9936 17.5687 18.0062 17.5023 18.0056C17.4359 18.0051 17.3703 17.9913 17.3093 17.9651C17.2483 17.9389 17.1931 17.9008 17.147 17.853L14.147 14.853C14.1041 14.8106 14.0692 14.7608 14.044 14.706Z" fill="white"></path>
              </svg>
            </button>
          </div>
        </div>
        <div id="left-section4">
          <div><p>目录</p><ul><li><p>Collcetion</p><ul data-path="."><li><p>鸿蒙开发</p><ul data-path="./鸿蒙开发"><li><p>一次开发,多端部署</p><ul data-path="./鸿蒙开发/一次开发,多端部署"><li><a href="/blog/post/html/./鸿蒙开发/一次开发,多端部署/v12笔记.html" data-path="./鸿蒙开发/一次开发,多端部署/v12笔记.md">v12笔记</a></li><li><p>undefined</p><ul data-path="./鸿蒙开发/一次开发,多端部署/img"></ul></li></ul></li><li><p>ArkData(方舟数据管理)</p><ul data-path="./鸿蒙开发/ArkData(方舟数据管理)"><li><a href="/blog/post/html/./鸿蒙开发/ArkData(方舟数据管理)/v12笔记.html" data-path="./鸿蒙开发/ArkData(方舟数据管理)/v12笔记.md">v12笔记</a></li><li><p>img</p><ul data-path="./鸿蒙开发/ArkData(方舟数据管理)/img"></ul></li></ul></li></ul></li><li><p>项目</p><ul data-path="./项目"><li><p>Vscode调试Nodejs</p><ul data-path="./项目/Vscode调试Nodejs"><li><p>img</p><ul data-path="./项目/Vscode调试Nodejs/img"></ul></li><li><a href="/blog/post/html/./项目/Vscode调试Nodejs/1. Vscode调试Nodejs.html" data-path="./项目/Vscode调试Nodejs/1. Vscode调试Nodejs.md">1. Vscode调试Nodejs</a></li></ul></li><li><p>Rust 项目</p><ul data-path="./项目/Rust 项目"><li><p>项目管理</p><ul data-path="./项目/Rust 项目/项目管理"><li><a href="/blog/post/html/./项目/Rust 项目/项目管理/Untitled.html" data-path="./项目/Rust 项目/项目管理/Untitled.md">Untitled</a></li></ul></li><li><a href="/blog/post/html/./项目/Rust 项目/Untitled.html" data-path="./项目/Rust 项目/Untitled.md">Untitled</a></li><li><p>Rust博客</p><ul data-path="./项目/Rust 项目/Rust博客"><li><a href="/blog/post/html/./项目/Rust 项目/Rust博客/Rust博客.html" data-path="./项目/Rust 项目/Rust博客/Rust博客.md">Rust博客</a></li></ul></li><li><a href="/blog/post/html/./项目/Rust 项目/Rust Axum 项目教程.html" data-path="./项目/Rust 项目/Rust Axum 项目教程.md">Rust Axum 项目教程</a></li><li><p>img</p><ul data-path="./项目/Rust 项目/img"></ul></li><li><a href="/blog/post/html/./项目/Rust 项目/01_Axum基础.html" data-path="./项目/Rust 项目/01_Axum基础.md">01_Axum基础</a></li></ul></li></ul></li><li><a href="/blog/post/html/./空间.html" data-path="./空间.md">空间</a></li><li><p>知识</p><ul data-path="./知识"><li><p>金融领域</p><ul data-path="./知识/金融领域"><li><a href="/blog/post/html/./知识/金融领域/专业名词.html" data-path="./知识/金融领域/专业名词.md">专业名词</a></li></ul></li></ul></li><li><a href="/blog/post/html/./未命名 1.html" data-path="./未命名 1.md">未命名 1</a></li><li><p>日志</p><ul data-path="./日志"><li><a href="/blog/post/html/./日志/Untitled 1.html" data-path="./日志/Untitled 1.md">Untitled 1</a></li><li><a href="/blog/post/html/./日志/Git Token.html" data-path="./日志/Git Token.md">Git Token</a></li></ul></li><li><p>加密货币</p><ul data-path="./加密货币"><li><a href="/blog/post/html/./加密货币/Untitled.html" data-path="./加密货币/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./加密货币/Untitled 1.html" data-path="./加密货币/Untitled 1.md">Untitled 1</a></li></ul></li><li><a href="/blog/post/html/./出图工作流程教程.html" data-path="./出图工作流程教程.md">出图工作流程教程</a></li><li><a href="/blog/post/html/./Untitled.html" data-path="./Untitled.md">Untitled</a></li><li><p>Untitled Folder</p><ul data-path="./Untitled Folder"><li><a href="/blog/post/html/./Untitled Folder/11111记录.html" data-path="./Untitled Folder/11111记录.md">11111记录</a></li></ul></li><li><p>Telegram bot</p><ul data-path="./Telegram bot"><li><a href="/blog/post/html/./Telegram bot/Untitled 1.html" data-path="./Telegram bot/Untitled 1.md">Untitled 1</a></li><li><a href="/blog/post/html/./Telegram bot/Telegram Bot.html" data-path="./Telegram bot/Telegram Bot.md">Telegram Bot</a></li></ul></li><li><a href="/blog/post/html/./SUI 笔记.html" data-path="./SUI 笔记.md">SUI 笔记</a></li><li><p>CC++</p><ul data-path="./CC++"><li><a href="/blog/post/html/./CC++/CMake基础.html" data-path="./CC++/CMake基础.md">CMake基础</a></li><li><a href="/blog/post/html/./CC++/C 语言基础.html" data-path="./CC++/C 语言基础.md">C 语言基础</a></li></ul></li><li><p>9.数据库笔记</p><ul data-path="./9.数据库笔记"><li><p>undefined</p><ul data-path="./9.数据库笔记/3.Mongodb"></ul></li><li><p>undefined</p><ul data-path="./9.数据库笔记/2.Redis"></ul></li><li><p>1.mysql</p><ul data-path="./9.数据库笔记/1.mysql"><li><a href="/blog/post/html/./9.数据库笔记/1.mysql/mysql配置文件.html" data-path="./9.数据库笔记/1.mysql/mysql配置文件.md">mysql配置文件</a></li><li><a href="/blog/post/html/./9.数据库笔记/1.mysql/mysql底层数据结构-索引规约.html" data-path="./9.数据库笔记/1.mysql/mysql底层数据结构-索引规约.md">mysql底层数据结构-索引规约</a></li><li><a href="/blog/post/html/./9.数据库笔记/1.mysql/day01.html" data-path="./9.数据库笔记/1.mysql/day01.md">day01</a></li><li><a href="/blog/post/html/./9.数据库笔记/1.mysql/4.DCL数据控制语言.html" data-path="./9.数据库笔记/1.mysql/4.DCL数据控制语言.md">4.DCL数据控制语言</a></li><li><a href="/blog/post/html/./9.数据库笔记/1.mysql/3.DQL数据查询语言.html" data-path="./9.数据库笔记/1.mysql/3.DQL数据查询语言.md">3.DQL数据查询语言</a></li><li><a href="/blog/post/html/./9.数据库笔记/1.mysql/2.DML数据操作语言.html" data-path="./9.数据库笔记/1.mysql/2.DML数据操作语言.md">2.DML数据操作语言</a></li><li><a href="/blog/post/html/./9.数据库笔记/1.mysql/1.DDL数据定义语言.html" data-path="./9.数据库笔记/1.mysql/1.DDL数据定义语言.md">1.DDL数据定义语言</a></li></ul></li></ul></li><li><p>8.svn和git笔记</p><ul data-path="./8.svn和git笔记"><li><p>SVN</p><ul data-path="./8.svn和git笔记/SVN"><li><a href="/blog/post/html/./8.svn和git笔记/SVN/SVN.html" data-path="./8.svn和git笔记/SVN/SVN.md">SVN</a></li><li><p>img</p><ul data-path="./8.svn和git笔记/SVN/img"></ul></li></ul></li><li><p>git</p><ul data-path="./8.svn和git笔记/git"><li><p>img</p><ul data-path="./8.svn和git笔记/git/img"></ul></li><li><a href="/blog/post/html/./8.svn和git笔记/git/GIT.html" data-path="./8.svn和git笔记/git/GIT.md">GIT</a></li><li><a href="/blog/post/html/./8.svn和git笔记/git/2. IDEA git.html" data-path="./8.svn和git笔记/git/2. IDEA git.md">2. IDEA git</a></li><li><a href="/blog/post/html/./8.svn和git笔记/git/1.GUI工具.html" data-path="./8.svn和git笔记/git/1.GUI工具.md">1.GUI工具</a></li></ul></li></ul></li><li><p>7.Linux笔记</p><ul data-path="./7.Linux笔记"><li><a href="/blog/post/html/./7.Linux笔记/代理.html" data-path="./7.Linux笔记/代理.md">代理</a></li><li><p>wsl</p><ul data-path="./7.Linux笔记/wsl"><li><a href="/blog/post/html/./7.Linux笔记/wsl/桌面化.html" data-path="./7.Linux笔记/wsl/桌面化.md">桌面化</a></li><li><a href="/blog/post/html/./7.Linux笔记/wsl/Untitled 1.html" data-path="./7.Linux笔记/wsl/Untitled 1.md">Untitled 1</a></li></ul></li><li><p>ssh</p><ul data-path="./7.Linux笔记/ssh"><li><a href="/blog/post/html/./7.Linux笔记/ssh/Untitled.html" data-path="./7.Linux笔记/ssh/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./7.Linux笔记/ssh/Untitled 1.html" data-path="./7.Linux笔记/ssh/Untitled 1.md">Untitled 1</a></li></ul></li><li><a href="/blog/post/html/./7.Linux笔记/ftp.html" data-path="./7.Linux笔记/ftp.md">ftp</a></li><li><p>9.用户组管理</p><ul data-path="./7.Linux笔记/9.用户组管理"><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/9.pts(0-9)输出到其他用户.html" data-path="./7.Linux笔记/9.用户组管理/9.pts(0-9)输出到其他用户.md">9.pts(0-9)输出到其他用户</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/8.su 切换用户.html" data-path="./7.Linux笔记/9.用户组管理/8.su 切换用户.md">8.su 切换用户</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/7.groupdel 删除分组.html" data-path="./7.Linux笔记/9.用户组管理/7.groupdel 删除分组.md">7.groupdel 删除分组</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/6.groupadd 添加分组.html" data-path="./7.Linux笔记/9.用户组管理/6.groupadd 添加分组.md">6.groupadd 添加分组</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/5.usermod 修改用户.html" data-path="./7.Linux笔记/9.用户组管理/5.usermod 修改用户.md">5.usermod 修改用户</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/4.userdel 删除用户.html" data-path="./7.Linux笔记/9.用户组管理/4.userdel 删除用户.md">4.userdel 删除用户</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/3.useradd添加用户.html" data-path="./7.Linux笔记/9.用户组管理/3.useradd添加用户.md">3.useradd添加用户</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/2.passwd 修改密码.html" data-path="./7.Linux笔记/9.用户组管理/2.passwd 修改密码.md">2.passwd 修改密码</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/10.etcxxx系统文件管理用户.html" data-path="./7.Linux笔记/9.用户组管理/10.etcxxx系统文件管理用户.md">10.etcxxx系统文件管理用户</a></li><li><a href="/blog/post/html/./7.Linux笔记/9.用户组管理/1.fuser -k踢出其他用户.html" data-path="./7.Linux笔记/9.用户组管理/1.fuser -k踢出其他用户.md">1.fuser -k踢出其他用户</a></li></ul></li><li><p>8.vim</p><ul data-path="./7.Linux笔记/8.vim"><li><p>阅读材料</p><ul data-path="./7.Linux笔记/8.vim/阅读材料"><li><a href="/blog/post/html/./7.Linux笔记/8.vim/阅读材料/基本vimrc设置.html" data-path="./7.Linux笔记/8.vim/阅读材料/基本vimrc设置.md">基本vimrc设置</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/阅读材料/21条操作.html" data-path="./7.Linux笔记/8.vim/阅读材料/21条操作.md">21条操作</a></li></ul></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/vim.html" data-path="./7.Linux笔记/8.vim/vim.md">vim</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/9.排版.html" data-path="./7.Linux笔记/8.vim/9.排版.md">9.排版</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/8.移动.html" data-path="./7.Linux笔记/8.vim/8.移动.md">8.移动</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/7.退出保存.html" data-path="./7.Linux笔记/8.vim/7.退出保存.md">7.退出保存</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/6.复制粘贴.html" data-path="./7.Linux笔记/8.vim/6.复制粘贴.md">6.复制粘贴</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/5.删除.html" data-path="./7.Linux笔记/8.vim/5.删除.md">5.删除</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/4.撤销的撤销.html" data-path="./7.Linux笔记/8.vim/4.撤销的撤销.md">4.撤销的撤销</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/3.替换.html" data-path="./7.Linux笔记/8.vim/3.替换.md">3.替换</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/2.查找.html" data-path="./7.Linux笔记/8.vim/2.查找.md">2.查找</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/17.设置.html" data-path="./7.Linux笔记/8.vim/17.设置.md">17.设置</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/16.挂起和执行命令.html" data-path="./7.Linux笔记/8.vim/16.挂起和执行命令.md">16.挂起和执行命令</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/14.文档加密.html" data-path="./7.Linux笔记/8.vim/14.文档加密.md">14.文档加密</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/13.窗口控制.html" data-path="./7.Linux笔记/8.vim/13.窗口控制.md">13.窗口控制</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/12.可视和全选.html" data-path="./7.Linux笔记/8.vim/12.可视和全选.md">12.可视和全选</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/11.视野.html" data-path="./7.Linux笔记/8.vim/11.视野.md">11.视野</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/10.注释.html" data-path="./7.Linux笔记/8.vim/10.注释.md">10.注释</a></li><li><a href="/blog/post/html/./7.Linux笔记/8.vim/1.打开文件.html" data-path="./7.Linux笔记/8.vim/1.打开文件.md">1.打开文件</a></li></ul></li><li><p>7.脚本</p><ul data-path="./7.Linux笔记/7.脚本"><li><a href="/blog/post/html/./7.Linux笔记/7.脚本/Untitled.html" data-path="./7.Linux笔记/7.脚本/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./7.Linux笔记/7.脚本/Untitled 1.html" data-path="./7.Linux笔记/7.脚本/Untitled 1.md">Untitled 1</a></li></ul></li><li><p>6.环境</p><ul data-path="./7.Linux笔记/6.环境"><li><a href="/blog/post/html/./7.Linux笔记/6.环境/1..html" data-path="./7.Linux笔记/6.环境/1..md">1.</a></li></ul></li><li><p>undefined</p><ul data-path="./7.Linux笔记/5.自动任务"></ul></li><li><p>4.防火墙</p><ul data-path="./7.Linux笔记/4.防火墙"><li><p>阅读材料</p><ul data-path="./7.Linux笔记/4.防火墙/阅读材料"><li><a href="/blog/post/html/./7.Linux笔记/4.防火墙/阅读材料/firewall-cmd.html" data-path="./7.Linux笔记/4.防火墙/阅读材料/firewall-cmd.md">firewall-cmd</a></li></ul></li><li><a href="/blog/post/html/./7.Linux笔记/4.防火墙/网络.html" data-path="./7.Linux笔记/4.防火墙/网络.md">网络</a></li><li><a href="/blog/post/html/./7.Linux笔记/4.防火墙/3.查看端口状态.html" data-path="./7.Linux笔记/4.防火墙/3.查看端口状态.md">3.查看端口状态</a></li><li><a href="/blog/post/html/./7.Linux笔记/4.防火墙/2.firewall-cmd.html" data-path="./7.Linux笔记/4.防火墙/2.firewall-cmd.md">2.firewall-cmd</a></li><li><a href="/blog/post/html/./7.Linux笔记/4.防火墙/1.iptable.html" data-path="./7.Linux笔记/4.防火墙/1.iptable.md">1.iptable</a></li></ul></li><li><p>3.systemd 服务</p><ul data-path="./7.Linux笔记/3.systemd 服务"><li><a href="/blog/post/html/./7.Linux笔记/3.systemd 服务/1..html" data-path="./7.Linux笔记/3.systemd 服务/1..md">1.</a></li></ul></li><li><p>2.awk、sed、grep</p><ul data-path="./7.Linux笔记/2.awk、sed、grep"><li><a href="/blog/post/html/./7.Linux笔记/2.awk、sed、grep/sed.html" data-path="./7.Linux笔记/2.awk、sed、grep/sed.md">sed</a></li></ul></li><li><p>14.磁盘</p><ul data-path="./7.Linux笔记/14.磁盘"><li><a href="/blog/post/html/./7.Linux笔记/14.磁盘/1. 交换空间swapfile.html" data-path="./7.Linux笔记/14.磁盘/1. 交换空间swapfile.md">1. 交换空间swapfile</a></li></ul></li><li><p>13.XShell使用</p><ul data-path="./7.Linux笔记/13.XShell使用"><li><a href="/blog/post/html/./7.Linux笔记/13.XShell使用/退格乱码问题.html" data-path="./7.Linux笔记/13.XShell使用/退格乱码问题.md">退格乱码问题</a></li></ul></li><li><p>12.安装</p><ul data-path="./7.Linux笔记/12.安装"><li><a href="/blog/post/html/./7.Linux笔记/12.安装/3.Ubuntu安装工具.html" data-path="./7.Linux笔记/12.安装/3.Ubuntu安装工具.md">3.Ubuntu安装工具</a></li><li><a href="/blog/post/html/./7.Linux笔记/12.安装/2.deb包安装.html" data-path="./7.Linux笔记/12.安装/2.deb包安装.md">2.deb包安装</a></li><li><a href="/blog/post/html/./7.Linux笔记/12.安装/1.rpm包安装.html" data-path="./7.Linux笔记/12.安装/1.rpm包安装.md">1.rpm包安装</a></li></ul></li><li><p>11.打包解压备份</p><ul data-path="./7.Linux笔记/11.打包解压备份"><li><a href="/blog/post/html/./7.Linux笔记/11.打包解压备份/3.zip.html" data-path="./7.Linux笔记/11.打包解压备份/3.zip.md">3.zip</a></li><li><a href="/blog/post/html/./7.Linux笔记/11.打包解压备份/2.gzip.html" data-path="./7.Linux笔记/11.打包解压备份/2.gzip.md">2.gzip</a></li><li><a href="/blog/post/html/./7.Linux笔记/11.打包解压备份/1.tar打包工具.html" data-path="./7.Linux笔记/11.打包解压备份/1.tar打包工具.md">1.tar打包工具</a></li></ul></li><li><p>10.文件权限</p><ul data-path="./7.Linux笔记/10.文件权限"><li><a href="/blog/post/html/./7.Linux笔记/10.文件权限/1.chmod.html" data-path="./7.Linux笔记/10.文件权限/1.chmod.md">1.chmod</a></li></ul></li><li><p>1. 常用命令</p><ul data-path="./7.Linux笔记/1. 常用命令"><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/9.head.html" data-path="./7.Linux笔记/1. 常用命令/9.head.md">9.head</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/8.cat.html" data-path="./7.Linux笔记/1. 常用命令/8.cat.md">8.cat</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/7.rm.html" data-path="./7.Linux笔记/1. 常用命令/7.rm.md">7.rm</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/6.touch.html" data-path="./7.Linux笔记/1. 常用命令/6.touch.md">6.touch</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/5.mv.html" data-path="./7.Linux笔记/1. 常用命令/5.mv.md">5.mv</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/4.cp.html" data-path="./7.Linux笔记/1. 常用命令/4.cp.md">4.cp</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/3.mkdir.html" data-path="./7.Linux笔记/1. 常用命令/3.mkdir.md">3.mkdir</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/2.ls.html" data-path="./7.Linux笔记/1. 常用命令/2.ls.md">2.ls</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/16.echo.html" data-path="./7.Linux笔记/1. 常用命令/16.echo.md">16.echo</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/14.ln 创建链接.html" data-path="./7.Linux笔记/1. 常用命令/14.ln 创建链接.md">14.ln 创建链接</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/13.find.html" data-path="./7.Linux笔记/1. 常用命令/13.find.md">13.find</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/12.scp.html" data-path="./7.Linux笔记/1. 常用命令/12.scp.md">12.scp</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/11.chmod.html" data-path="./7.Linux笔记/1. 常用命令/11.chmod.md">11.chmod</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/10.tail.html" data-path="./7.Linux笔记/1. 常用命令/10.tail.md">10.tail</a></li><li><a href="/blog/post/html/./7.Linux笔记/1. 常用命令/1.pwd.html" data-path="./7.Linux笔记/1. 常用命令/1.pwd.md">1.pwd</a></li></ul></li></ul></li><li><p>6.supermemo</p><ul data-path="./6.supermemo"><li><a href="/blog/post/html/./6.supermemo/音频的解决办法.html" data-path="./6.supermemo/音频的解决办法.md">音频的解决办法</a></li><li><a href="/blog/post/html/./6.supermemo/supermemo工具.html" data-path="./6.supermemo/supermemo工具.md">supermemo工具</a></li><li><a href="/blog/post/html/./6.supermemo/Quicker工具.html" data-path="./6.supermemo/Quicker工具.md">Quicker工具</a></li><li><a href="/blog/post/html/./6.supermemo/autohotkey工具.html" data-path="./6.supermemo/autohotkey工具.md">autohotkey工具</a></li><li><a href="/blog/post/html/./6.supermemo/anki工具.html" data-path="./6.supermemo/anki工具.md">anki工具</a></li></ul></li><li><p>5.latex笔记</p><ul data-path="./5.latex笔记"><li><a href="/blog/post/html/./5.latex笔记/1.html" data-path="./5.latex笔记/1.md">1</a></li></ul></li><li><p>4.markdown快捷键</p><ul data-path="./4.markdown快捷键"><li><a href="/blog/post/html/./4.markdown快捷键/自动完成.html" data-path="./4.markdown快捷键/自动完成.md">自动完成</a></li><li><a href="/blog/post/html/./4.markdown快捷键/YAML.html" data-path="./4.markdown快捷键/YAML.md">YAML</a></li><li><a href="/blog/post/html/./4.markdown快捷键/Typora快速绘图.html" data-path="./4.markdown快捷键/Typora快速绘图.md">Typora快速绘图</a></li><li><a href="/blog/post/html/./4.markdown快捷键/mermaid图.html" data-path="./4.markdown快捷键/mermaid图.md">mermaid图</a></li><li><a href="/blog/post/html/./4.markdown快捷键/Markdown数学公式语法.html" data-path="./4.markdown快捷键/Markdown数学公式语法.md">Markdown数学公式语法</a></li><li><a href="/blog/post/html/./4.markdown快捷键/markdown手册.html" data-path="./4.markdown快捷键/markdown手册.md">markdown手册</a></li><li><a href="/blog/post/html/./4.markdown快捷键/flow图.html" data-path="./4.markdown快捷键/flow图.md">flow图</a></li></ul></li><li><p>3.wolfram笔记</p><ul data-path="./3.wolfram笔记"><li><a href="/blog/post/html/./3.wolfram笔记/教材.html" data-path="./3.wolfram笔记/教材.md">教材</a></li><li><p>《编程指南》</p><ul data-path="./3.wolfram笔记/《编程指南》"></ul></li><li><a href="/blog/post/html/./3.wolfram笔记/wolfram编辑技巧.html" data-path="./3.wolfram笔记/wolfram编辑技巧.md">wolfram编辑技巧</a></li><li><a href="/blog/post/html/./3.wolfram笔记/wolfram.html" data-path="./3.wolfram笔记/wolfram.md">wolfram</a></li></ul></li><li><p>22.效率工具</p><ul data-path="./22.效率工具"><li><p>undefined</p><ul data-path="./22.效率工具/joplin笔记软件"></ul></li></ul></li><li><p>21.工作</p><ul data-path="./21.工作"><li><a href="/blog/post/html/./21.工作/Untitled.html" data-path="./21.工作/Untitled.md">Untitled</a></li><li><p>9. Training</p><ul data-path="./21.工作/9. Training"><li><a href="/blog/post/html/./21.工作/9. Training/training1.html" data-path="./21.工作/9. Training/training1.md">training1</a></li></ul></li><li><p>8. 项目管理</p><ul data-path="./21.工作/8. 项目管理"><li><a href="/blog/post/html/./21.工作/8. 项目管理/项目管理——Jira.html" data-path="./21.工作/8. 项目管理/项目管理——Jira.md">项目管理——Jira</a></li><li><p>img</p><ul data-path="./21.工作/8. 项目管理/img"></ul></li></ul></li><li><p>undefined</p><ul data-path="./21.工作/7.git"></ul></li><li><p>undefined</p><ul data-path="./21.工作/6.设计模式"></ul></li><li><p>undefined</p><ul data-path="./21.工作/5.消息"></ul></li><li><p>4.锁</p><ul data-path="./21.工作/4.锁"><li><a href="/blog/post/html/./21.工作/4.锁/2.Redis锁.html" data-path="./21.工作/4.锁/2.Redis锁.md">2.Redis锁</a></li><li><a href="/blog/post/html/./21.工作/4.锁/1.java锁.html" data-path="./21.工作/4.锁/1.java锁.md">1.java锁</a></li></ul></li><li><p>undefined</p><ul data-path="./21.工作/3.事务"></ul></li><li><p>2.java</p><ul data-path="./21.工作/2.java"><li><a href="/blog/post/html/./21.工作/2.java/4.匿名.html" data-path="./21.工作/2.java/4.匿名.md">4.匿名</a></li><li><a href="/blog/post/html/./21.工作/2.java/3.流式.html" data-path="./21.工作/2.java/3.流式.md">3.流式</a></li><li><a href="/blog/post/html/./21.工作/2.java/2.字符.html" data-path="./21.工作/2.java/2.字符.md">2.字符</a></li><li><a href="/blog/post/html/./21.工作/2.java/1.优化.html" data-path="./21.工作/2.java/1.优化.md">1.优化</a></li></ul></li><li><p>1.springboot</p><ul data-path="./21.工作/1.springboot"><li><a href="/blog/post/html/./21.工作/1.springboot/3.测试.html" data-path="./21.工作/1.springboot/3.测试.md">3.测试</a></li><li><a href="/blog/post/html/./21.工作/1.springboot/2.依赖.html" data-path="./21.工作/1.springboot/2.依赖.md">2.依赖</a></li><li><a href="/blog/post/html/./21.工作/1.springboot/1.配置.html" data-path="./21.工作/1.springboot/1.配置.md">1.配置</a></li></ul></li></ul></li><li><p>21. 前端技术</p><ul data-path="./21. 前端技术"><li><p>打包</p><ul data-path="./21. 前端技术/打包"><li><p>webpack5</p><ul data-path="./21. 前端技术/打包/webpack5"><li><a href="/blog/post/html/./21. 前端技术/打包/webpack5/概念.html" data-path="./21. 前端技术/打包/webpack5/概念.md">概念</a></li><li><a href="/blog/post/html/./21. 前端技术/打包/webpack5/指南.html" data-path="./21. 前端技术/打包/webpack5/指南.md">指南</a></li><li><p>img</p><ul data-path="./21. 前端技术/打包/webpack5/img"></ul></li></ul></li></ul></li><li><p>vuetify组件</p><ul data-path="./21. 前端技术/vuetify组件"><li><p>指令</p><ul data-path="./21. 前端技术/vuetify组件/指令"><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/指令/3.缩放指令.html" data-path="./21. 前端技术/vuetify组件/指令/3.缩放指令.md">3.缩放指令</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/指令/2.波纹指令.html" data-path="./21. 前端技术/vuetify组件/指令/2.波纹指令.md">2.波纹指令</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/指令/1.在外部点击.html" data-path="./21. 前端技术/vuetify组件/指令/1.在外部点击.md">1.在外部点击</a></li></ul></li><li><p>UI组件</p><ul data-path="./21. 前端技术/vuetify组件/UI组件"><li><p>img</p><ul data-path="./21. 前端技术/vuetify组件/UI组件/img"></ul></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/9.提示Tooltips.html" data-path="./21. 前端技术/vuetify组件/UI组件/9.提示Tooltips.md">9.提示Tooltips</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/8.选项卡Tabs.html" data-path="./21. 前端技术/vuetify组件/UI组件/8.选项卡Tabs.md">8.选项卡Tabs</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/7.消息条Snack.html" data-path="./21. 前端技术/vuetify组件/UI组件/7.消息条Snack.md">7.消息条Snack</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/6.悬停Hover.html" data-path="./21. 前端技术/vuetify组件/UI组件/6.悬停Hover.md">6.悬停Hover</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/5.列表List.html" data-path="./21. 前端技术/vuetify组件/UI组件/5.列表List.md">5.列表List</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/4.表格table.html" data-path="./21. 前端技术/vuetify组件/UI组件/4.表格table.md">4.表格table</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/3.表单form.html" data-path="./21. 前端技术/vuetify组件/UI组件/3.表单form.md">3.表单form</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/2.导航nav和bar.html" data-path="./21. 前端技术/vuetify组件/UI组件/2.导航nav和bar.md">2.导航nav和bar</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/10.卡片Card.html" data-path="./21. 前端技术/vuetify组件/UI组件/10.卡片Card.md">10.卡片Card</a></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/UI组件/1.对话框dialog.html" data-path="./21. 前端技术/vuetify组件/UI组件/1.对话框dialog.md">1.对话框dialog</a></li></ul></li><li><a href="/blog/post/html/./21. 前端技术/vuetify组件/1. 记录.html" data-path="./21. 前端技术/vuetify组件/1. 记录.md">1. 记录</a></li></ul></li><li><a href="/blog/post/html/./21. 前端技术/Vscode 插件开发.html" data-path="./21. 前端技术/Vscode 插件开发.md">Vscode 插件开发</a></li><li><p>uidesign</p><ul data-path="./21. 前端技术/uidesign"><li><p>设计规范</p><ul data-path="./21. 前端技术/uidesign/设计规范"><li><a href="/blog/post/html/./21. 前端技术/uidesign/设计规范/设计规范.html" data-path="./21. 前端技术/uidesign/设计规范/设计规范.md">设计规范</a></li><li><p>img</p><ul data-path="./21. 前端技术/uidesign/设计规范/img"></ul></li></ul></li><li><a href="/blog/post/html/./21. 前端技术/uidesign/uidesign.html" data-path="./21. 前端技术/uidesign/uidesign.md">uidesign</a></li><li><p>ps</p><ul data-path="./21. 前端技术/uidesign/ps"><li><a href="/blog/post/html/./21. 前端技术/uidesign/ps/ps.html" data-path="./21. 前端技术/uidesign/ps/ps.md">ps</a></li><li><p>img</p><ul data-path="./21. 前端技术/uidesign/ps/img"></ul></li></ul></li><li><p>axure</p><ul data-path="./21. 前端技术/uidesign/axure"><li><p>img</p><ul data-path="./21. 前端技术/uidesign/axure/img"></ul></li><li><a href="/blog/post/html/./21. 前端技术/uidesign/axure/axure.html" data-path="./21. 前端技术/uidesign/axure/axure.md">axure</a></li></ul></li></ul></li><li><p>storybook</p><ul data-path="./21. 前端技术/storybook"><li><a href="/blog/post/html/./21. 前端技术/storybook/storybook.html" data-path="./21. 前端技术/storybook/storybook.md">storybook</a></li></ul></li><li><p>React</p><ul data-path="./21. 前端技术/React"><li><p>chapter1</p><ul data-path="./21. 前端技术/React/chapter1"><li><p>demo01</p><ul data-path="./21. 前端技术/React/chapter1/demo01"><li><p>robot-gallary</p><ul data-path="./21. 前端技术/React/chapter1/demo01/robot-gallary"><li><p>src</p><ul data-path="./21. 前端技术/React/chapter1/demo01/robot-gallary/src"></ul></li><li><a href="/blog/post/html/./21. 前端技术/React/chapter1/demo01/robot-gallary/README.html" data-path="./21. 前端技术/React/chapter1/demo01/robot-gallary/README.md">README</a></li><li><p>public</p><ul data-path="./21. 前端技术/React/chapter1/demo01/robot-gallary/public"></ul></li></ul></li><li><p>undefined</p><ul data-path="./21. 前端技术/React/chapter1/demo01/abc"></ul></li></ul></li><li><a href="/blog/post/html/./21. 前端技术/React/chapter1/1.react基础.html" data-path="./21. 前端技术/React/chapter1/1.react基础.md">1.react基础</a></li></ul></li><li><a href="/blog/post/html/./21. 前端技术/React/1.react基础.html" data-path="./21. 前端技术/React/1.react基础.md">1.react基础</a></li></ul></li><li><p>New folder</p><ul data-path="./21. 前端技术/New folder"><li><p>img</p><ul data-path="./21. 前端技术/New folder/img"></ul></li></ul></li><li><p>Lit</p><ul data-path="./21. 前端技术/Lit"><li><a href="/blog/post/html/./21. 前端技术/Lit/Untitled.html" data-path="./21. 前端技术/Lit/Untitled.md">Untitled</a></li><li><p>img</p><ul data-path="./21. 前端技术/Lit/img"></ul></li><li><a href="/blog/post/html/./21. 前端技术/Lit/9. Comps - Shadow Dom.html" data-path="./21. 前端技术/Lit/9. Comps - Shadow Dom.md">9. Comps - Shadow Dom</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/8. Comps - Lifecycle.html" data-path="./21. 前端技术/Lit/8. Comps - Lifecycle.md">8. Comps - Lifecycle</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/7. Comps - Properties.html" data-path="./21. 前端技术/Lit/7. Comps - Properties.md">7. Comps - Properties</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/6. Comps - Reactive.html" data-path="./21. 前端技术/Lit/6. Comps - Reactive.md">6. Comps - Reactive</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/5. Comps - Rendering.html" data-path="./21. 前端技术/Lit/5. Comps - Rendering.md">5. Comps - Rendering</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/4. Comps - Defining.html" data-path="./21. 前端技术/Lit/4. Comps - Defining.md">4. Comps - Defining</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/3. Comps - Overview.html" data-path="./21. 前端技术/Lit/3. Comps - Overview.md">3. Comps - Overview</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/23. Managing Data - Async Tasks.html" data-path="./21. 前端技术/Lit/23. Managing Data - Async Tasks.md">23. Managing Data - Async Tasks</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/22. Managing Data - Context.html" data-path="./21. 前端技术/Lit/22. Managing Data - Context.md">22. Managing Data - Context</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/21. Composition - Controllers.html" data-path="./21. 前端技术/Lit/21. Composition - Controllers.md">21. Composition - Controllers</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/20. Composition - Mixins.html" data-path="./21. 前端技术/Lit/20. Composition - Mixins.md">20. Composition - Mixins</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/2. Getting Started.html" data-path="./21. 前端技术/Lit/2. Getting Started.md">2. Getting Started</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/19. Composition -Component.html" data-path="./21. 前端技术/Lit/19. Composition -Component.md">19. Composition -Component</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/18. Composition - Overview.html" data-path="./21. 前端技术/Lit/18. Composition - Overview.md">18. Composition - Overview</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/17. Templates - Custom Directives.html" data-path="./21. 前端技术/Lit/17. Templates - Custom Directives.md">17. Templates - Custom Directives</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/16. Templates - Built in Directives.html" data-path="./21. 前端技术/Lit/16. Templates - Built in Directives.md">16. Templates - Built in Directives</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/14. Templates - Conditional.html" data-path="./21. 前端技术/Lit/14. Templates - Conditional.md">14. Templates - Conditional</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/13. Templates - Expressions.html" data-path="./21. 前端技术/Lit/13. Templates - Expressions.md">13. Templates - Expressions</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/12. Templates - Overview.html" data-path="./21. 前端技术/Lit/12. Templates - Overview.md">12. Templates - Overview</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/11. Comps - Decorators.html" data-path="./21. 前端技术/Lit/11. Comps - Decorators.md">11. Comps - Decorators</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/10. Comps - Events.html" data-path="./21. 前端技术/Lit/10. Comps - Events.md">10. Comps - Events</a></li><li><a href="/blog/post/html/./21. 前端技术/Lit/1. What is List.html" data-path="./21. 前端技术/Lit/1. What is List.md">1. What is List</a></li></ul></li><li><p>img</p><ul data-path="./21. 前端技术/img"></ul></li><li><p>demo</p><ul data-path="./21. 前端技术/demo"><li><a href="/blog/post/html/./21. 前端技术/demo/Untitled.html" data-path="./21. 前端技术/demo/Untitled.md">Untitled</a></li><li><p>Untitled.assets</p><ul data-path="./21. 前端技术/demo/Untitled.assets"></ul></li></ul></li><li><p>css</p><ul data-path="./21. 前端技术/css"><li><a href="/blog/post/html/./21. 前端技术/css/css基础知识.html" data-path="./21. 前端技术/css/css基础知识.md">css基础知识</a></li></ul></li><li><p>9.Vue框架</p><ul data-path="./21. 前端技术/9.Vue框架"><li><p>素材</p><ul data-path="./21. 前端技术/9.Vue框架/素材"><li><a href="/blog/post/html/./21. 前端技术/9.Vue框架/素材/Untitled.html" data-path="./21. 前端技术/9.Vue框架/素材/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./21. 前端技术/9.Vue框架/素材/Untitled 1.html" data-path="./21. 前端技术/9.Vue框架/素材/Untitled 1.md">Untitled 1</a></li><li><p>undefined</p><ul data-path="./21. 前端技术/9.Vue框架/素材/js"></ul></li><li><p>element-ui</p><ul data-path="./21. 前端技术/9.Vue框架/素材/element-ui"><li><p>fonts</p><ul data-path="./21. 前端技术/9.Vue框架/素材/element-ui/fonts"></ul></li></ul></li></ul></li><li><a href="/blog/post/html/./21. 前端技术/9.Vue框架/vue-admin-template.html" data-path="./21. 前端技术/9.Vue框架/vue-admin-template.md">vue-admin-template</a></li><li><a href="/blog/post/html/./21. 前端技术/9.Vue框架/VUE &amp; Vuetify.html" data-path="./21. 前端技术/9.Vue框架/VUE &amp; Vuetify.md">VUE &amp; Vuetify</a></li><li><a href="/blog/post/html/./21. 前端技术/9.Vue框架/VUE &amp; Axios &amp; ElementUI.html" data-path="./21. 前端技术/9.Vue框架/VUE &amp; Axios &amp; ElementUI.md">VUE &amp; Axios &amp; ElementUI</a></li><li><p>img</p><ul data-path="./21. 前端技术/9.Vue框架/img"></ul></li><li><a href="/blog/post/html/./21. 前端技术/9.Vue框架/1. vue笔记.html" data-path="./21. 前端技术/9.Vue框架/1. vue笔记.md">1. vue笔记</a></li></ul></li><li><p>1.nodejs</p><ul data-path="./21. 前端技术/1.nodejs"><li><a href="/blog/post/html/./21. 前端技术/1.nodejs/node多版本管理nvm.html" data-path="./21. 前端技术/1.nodejs/node多版本管理nvm.md">node多版本管理nvm</a></li><li><p>undefined</p><ul data-path="./21. 前端技术/1.nodejs/img"></ul></li><li><a href="/blog/post/html/./21. 前端技术/1.nodejs/code-snipaste.html" data-path="./21. 前端技术/1.nodejs/code-snipaste.md">code-snipaste</a></li></ul></li></ul></li><li><a href="/blog/post/html/./2022-02-12.html" data-path="./2022-02-12.md">2022-02-12</a></li><li><p>20. 桌面应用技术</p><ul data-path="./20. 桌面应用技术"><li><p>前端</p><ul data-path="./20. 桌面应用技术/前端"><li><p>img</p><ul data-path="./20. 桌面应用技术/前端/img"><li><a href="/blog/post/html/./20. 桌面应用技术/前端/img/GraphQL_basic.html" data-path="./20. 桌面应用技术/前端/img/GraphQL_basic.md">GraphQL_basic</a></li></ul></li><li><a href="/blog/post/html/./20. 桌面应用技术/前端/deno.html" data-path="./20. 桌面应用技术/前端/deno.md">deno</a></li><li><a href="/blog/post/html/./20. 桌面应用技术/前端/1.Overview.html" data-path="./20. 桌面应用技术/前端/1.Overview.md">1.Overview</a></li></ul></li><li><a href="/blog/post/html/./20. 桌面应用技术/Untitled.html" data-path="./20. 桌面应用技术/Untitled.md">Untitled</a></li><li><p>mvp-3700</p><ul data-path="./20. 桌面应用技术/mvp-3700"><li><a href="/blog/post/html/./20. 桌面应用技术/mvp-3700/未命名.html" data-path="./20. 桌面应用技术/mvp-3700/未命名.md">未命名</a></li></ul></li><li><p>img</p><ul data-path="./20. 桌面应用技术/img"></ul></li><li><p>electron</p><ul data-path="./20. 桌面应用技术/electron"><li><a href="/blog/post/html/./20. 桌面应用技术/electron/vue-electron.html" data-path="./20. 桌面应用技术/electron/vue-electron.md">vue-electron</a></li><li><p>undefined</p><ul data-path="./20. 桌面应用技术/electron/Untitled Folder"></ul></li><li><a href="/blog/post/html/./20. 桌面应用技术/electron/mtool.html" data-path="./20. 桌面应用技术/electron/mtool.md">mtool</a></li><li><a href="/blog/post/html/./20. 桌面应用技术/electron/electron笔记.html" data-path="./20. 桌面应用技术/electron/electron笔记.md">electron笔记</a></li><li><a href="/blog/post/html/./20. 桌面应用技术/electron/electron原理.html" data-path="./20. 桌面应用技术/electron/electron原理.md">electron原理</a></li></ul></li></ul></li><li><p>2.python笔记</p><ul data-path="./2.python笔记"><li><p>量化交易</p><ul data-path="./2.python笔记/量化交易"><li><a href="/blog/post/html/./2.python笔记/量化交易/Untitled.html" data-path="./2.python笔记/量化交易/Untitled.md">Untitled</a></li></ul></li><li><a href="/blog/post/html/./2.python笔记/杂记.html" data-path="./2.python笔记/杂记.md">杂记</a></li><li><a href="/blog/post/html/./2.python笔记/代码片段acire软件.html" data-path="./2.python笔记/代码片段acire软件.md">代码片段acire软件</a></li><li><a href="/blog/post/html/./2.python笔记/二级.html" data-path="./2.python笔记/二级.md">二级</a></li><li><a href="/blog/post/html/./2.python笔记/re模块.html" data-path="./2.python笔记/re模块.md">re模块</a></li><li><a href="/blog/post/html/./2.python笔记/python数学计算.html" data-path="./2.python笔记/python数学计算.md">python数学计算</a></li><li><a href="/blog/post/html/./2.python笔记/python手册.html" data-path="./2.python笔记/python手册.md">python手册</a></li><li><a href="/blog/post/html/./2.python笔记/Pandas基础命令速查表.html" data-path="./2.python笔记/Pandas基础命令速查表.md">Pandas基础命令速查表</a></li><li><a href="/blog/post/html/./2.python笔记/jupyter.html" data-path="./2.python笔记/jupyter.md">jupyter</a></li><li><a href="/blog/post/html/./2.python笔记/ipython.html" data-path="./2.python笔记/ipython.md">ipython</a></li></ul></li><li><p>19. docker部署技术</p><ul data-path="./19. docker部署技术"><li><a href="/blog/post/html/./19. docker部署技术/vue的docker方案.html" data-path="./19. docker部署技术/vue的docker方案.md">vue的docker方案</a></li><li><a href="/blog/post/html/./19. docker部署技术/virtual-box无法启动虚拟机.html" data-path="./19. docker部署技术/virtual-box无法启动虚拟机.md">virtual-box无法启动虚拟机</a></li><li><a href="/blog/post/html/./19. docker部署技术/vagrant 技巧.html" data-path="./19. docker部署技术/vagrant 技巧.md">vagrant 技巧</a></li><li><a href="/blog/post/html/./19. docker部署技术/vagrant &amp; docker &amp; virtualBox.html" data-path="./19. docker部署技术/vagrant &amp; docker &amp; virtualBox.md">vagrant &amp; docker &amp; virtualBox</a></li><li><a href="/blog/post/html/./19. docker部署技术/podman.html" data-path="./19. docker部署技术/podman.md">podman</a></li><li><a href="/blog/post/html/./19. docker部署技术/nginx的docker方案.html" data-path="./19. docker部署技术/nginx的docker方案.md">nginx的docker方案</a></li><li><p>nginx</p><ul data-path="./19. docker部署技术/nginx"><li><a href="/blog/post/html/./19. docker部署技术/nginx/nginx.html" data-path="./19. docker部署技术/nginx/nginx.md">nginx</a></li><li><p>img</p><ul data-path="./19. docker部署技术/nginx/img"></ul></li></ul></li><li><p>img</p><ul data-path="./19. docker部署技术/img"></ul></li><li><a href="/blog/post/html/./19. docker部署技术/docker笔记.html" data-path="./19. docker部署技术/docker笔记.md">docker笔记</a></li><li><a href="/blog/post/html/./19. docker部署技术/docker分享.html" data-path="./19. docker部署技术/docker分享.md">docker分享</a></li><li><a href="/blog/post/html/./19. docker部署技术/docker中容器与宿主机之间的网络关系.html" data-path="./19. docker部署技术/docker中容器与宿主机之间的网络关系.md">docker中容器与宿主机之间的网络关系</a></li><li><a href="/blog/post/html/./19. docker部署技术/docker 修改端口.html" data-path="./19. docker部署技术/docker 修改端口.md">docker 修改端口</a></li><li><a href="/blog/post/html/./19. docker部署技术/docker in docker.html" data-path="./19. docker部署技术/docker in docker.md">docker in docker</a></li><li><a href="/blog/post/html/./19. docker部署技术/docker - clean.html" data-path="./19. docker部署技术/docker - clean.md">docker - clean</a></li><li><a href="/blog/post/html/./19. docker部署技术/devOps.html" data-path="./19. docker部署技术/devOps.md">devOps</a></li></ul></li><li><p>18.代码片段管理</p><ul data-path="./18.代码片段管理"><li><p>前端代码</p><ul data-path="./18.代码片段管理/前端代码"><li><a href="/blog/post/html/./18.代码片段管理/前端代码/1.vue.html" data-path="./18.代码片段管理/前端代码/1.vue.md">1.vue</a></li></ul></li></ul></li><li><p>17.云计算</p><ul data-path="./17.云计算"><li><a href="/blog/post/html/./17.云计算/阿里云.html" data-path="./17.云计算/阿里云.md">阿里云</a></li><li><a href="/blog/post/html/./17.云计算/极客云.html" data-path="./17.云计算/极客云.md">极客云</a></li></ul></li><li><p>16.编辑器</p><ul data-path="./16.编辑器"><li><a href="/blog/post/html/./16.编辑器/plugin.html" data-path="./16.编辑器/plugin.md">plugin</a></li><li><a href="/blog/post/html/./16.编辑器/3.Obsidian.html" data-path="./16.编辑器/3.Obsidian.md">3.Obsidian</a></li><li><a href="/blog/post/html/./16.编辑器/2.idea.html" data-path="./16.编辑器/2.idea.md">2.idea</a></li><li><a href="/blog/post/html/./16.编辑器/1.vscode.html" data-path="./16.编辑器/1.vscode.md">1.vscode</a></li></ul></li><li><p>100._</p><ul data-path="./100._"><li><p>高数</p><ul data-path="./100._/高数"><li><a href="/blog/post/html/./100._/高数/草稿.html" data-path="./100._/高数/草稿.md">草稿</a></li><li><a href="/blog/post/html/./100._/高数/Untitled.html" data-path="./100._/高数/Untitled.md">Untitled</a></li><li><p>TempNote</p><ul data-path="./100._/高数/TempNote"></ul></li><li><a href="/blog/post/html/./100._/高数/6.微分.html" data-path="./100._/高数/6.微分.md">6.微分</a></li><li><a href="/blog/post/html/./100._/高数/3.6 三角代换.html" data-path="./100._/高数/3.6 三角代换.md">3.6 三角代换</a></li><li><a href="/blog/post/html/./100._/高数/3.5 简单无理根式换元法.html" data-path="./100._/高数/3.5 简单无理根式换元法.md">3.5 简单无理根式换元法</a></li><li><a href="/blog/post/html/./100._/高数/3.3凑微分法.html" data-path="./100._/高数/3.3凑微分法.md">3.3凑微分法</a></li><li><a href="/blog/post/html/./100._/高数/3.3 直接积分法1.html" data-path="./100._/高数/3.3 直接积分法1.md">3.3 直接积分法1</a></li><li><a href="/blog/post/html/./100._/高数/3.2直接积分法.html" data-path="./100._/高数/3.2直接积分法.md">3.2直接积分法</a></li><li><a href="/blog/post/html/./100._/高数/3.1不定积分.html" data-path="./100._/高数/3.1不定积分.md">3.1不定积分</a></li><li><a href="/blog/post/html/./100._/高数/2.变限积分.html" data-path="./100._/高数/2.变限积分.md">2.变限积分</a></li><li><a href="/blog/post/html/./100._/高数/2.9函数的凹凸性.html" data-path="./100._/高数/2.9函数的凹凸性.md">2.9函数的凹凸性</a></li><li><a href="/blog/post/html/./100._/高数/2.8函数的极值与驻点.html" data-path="./100._/高数/2.8函数的极值与驻点.md">2.8函数的极值与驻点</a></li><li><a href="/blog/post/html/./100._/高数/2.7导数与单调性的关系.html" data-path="./100._/高数/2.7导数与单调性的关系.md">2.7导数与单调性的关系</a></li><li><a href="/blog/post/html/./100._/高数/2.6函数的微分.html" data-path="./100._/高数/2.6函数的微分.md">2.6函数的微分</a></li><li><a href="/blog/post/html/./100._/高数/2.5高阶导数.html" data-path="./100._/高数/2.5高阶导数.md">2.5高阶导数</a></li><li><a href="/blog/post/html/./100._/高数/2.2.左导数与右导数.html" data-path="./100._/高数/2.2.左导数与右导数.md">2.2.左导数与右导数</a></li><li><a href="/blog/post/html/./100._/高数/2.1.导数.html" data-path="./100._/高数/2.1.导数.md">2.1.导数</a></li><li><a href="/blog/post/html/./100._/高数/1.4.无穷小量和渐近线.html" data-path="./100._/高数/1.4.无穷小量和渐近线.md">1.4.无穷小量和渐近线</a></li><li><a href="/blog/post/html/./100._/高数/1.3.函数的连续与间断.html" data-path="./100._/高数/1.3.函数的连续与间断.md">1.3.函数的连续与间断</a></li><li><a href="/blog/post/html/./100._/高数/1.2.函数的四个性质.html" data-path="./100._/高数/1.2.函数的四个性质.md">1.2.函数的四个性质</a></li><li><a href="/blog/post/html/./100._/高数/1.1.极限.html" data-path="./100._/高数/1.1.极限.md">1.1.极限</a></li></ul></li><li><a href="/blog/post/html/./100._/英语基础语法.html" data-path="./100._/英语基础语法.md">英语基础语法</a></li><li><p>自考</p><ul data-path="./100._/自考"><li><a href="/blog/post/html/./100._/自考/1. 信息资源管理知识点.html" data-path="./100._/自考/1. 信息资源管理知识点.md">1. 信息资源管理知识点</a></li></ul></li><li><p>考研</p><ul data-path="./100._/考研"><li><p>雅思</p><ul data-path="./100._/考研/雅思"><li><a href="/blog/post/html/./100._/考研/雅思/Part3 基础语法(特数句+长难句).html" data-path="./100._/考研/雅思/Part3 基础语法(特数句+长难句).md">Part3 基础语法(特数句+长难句)</a></li><li><a href="/blog/post/html/./100._/考研/雅思/Part2 基础语法(并列句+从句).html" data-path="./100._/考研/雅思/Part2 基础语法(并列句+从句).md">Part2 基础语法(并列句+从句)</a></li><li><a href="/blog/post/html/./100._/考研/雅思/Part1 基础语法(简单句).html" data-path="./100._/考研/雅思/Part1 基础语法(简单句).md">Part1 基础语法(简单句)</a></li><li><a href="/blog/post/html/./100._/考研/雅思/Part0 基础语法(目录+导图).html" data-path="./100._/考研/雅思/Part0 基础语法(目录+导图).md">Part0 基础语法(目录+导图)</a></li></ul></li><li><p>undefined</p><ul data-path="./100._/考研/数据结构"></ul></li><li><a href="/blog/post/html/./100._/考研/Untitled 1.html" data-path="./100._/考研/Untitled 1.md">Untitled 1</a></li></ul></li><li><p>结束的</p><ul data-path="./100._/结束的"><li><a href="/blog/post/html/./100._/结束的/教资.html" data-path="./100._/结束的/教资.md">教资</a></li><li><p>信息安全</p><ul data-path="./100._/结束的/信息安全"><li><a href="/blog/post/html/./100._/结束的/信息安全/第一次刷题.html" data-path="./100._/结束的/信息安全/第一次刷题.md">第一次刷题</a></li><li><a href="/blog/post/html/./100._/结束的/信息安全/信息安全三级.html" data-path="./100._/结束的/信息安全/信息安全三级.md">信息安全三级</a></li></ul></li></ul></li><li><p>数模</p><ul data-path="./100._/数模"><li><a href="/blog/post/html/./100._/数模/第二章.html" data-path="./100._/数模/第二章.md">第二章</a></li><li><a href="/blog/post/html/./100._/数模/第一章.html" data-path="./100._/数模/第一章.md">第一章</a></li><li><a href="/blog/post/html/./100._/数模/电路指导与考研.html" data-path="./100._/数模/电路指导与考研.md">电路指导与考研</a></li></ul></li><li><p>数学绘图工具</p><ul data-path="./100._/数学绘图工具"><li><a href="/blog/post/html/./100._/数学绘图工具/Geogebra动态绘图与计算.html" data-path="./100._/数学绘图工具/Geogebra动态绘图与计算.md">Geogebra动态绘图与计算</a></li></ul></li></ul></li><li><p>10.Rust笔记</p><ul data-path="./10.Rust笔记"><li><a href="/blog/post/html/./10.Rust笔记/项目配置.html" data-path="./10.Rust笔记/项目配置.md">项目配置</a></li><li><a href="/blog/post/html/./10.Rust笔记/基础.html" data-path="./10.Rust笔记/基础.md">基础</a></li><li><p>基础.assets</p><ul data-path="./10.Rust笔记/基础.assets"></ul></li><li><p>wasm</p><ul data-path="./10.Rust笔记/wasm"><li><a href="/blog/post/html/./10.Rust笔记/wasm/WebAssembly.html" data-path="./10.Rust笔记/wasm/WebAssembly.md">WebAssembly</a></li></ul></li><li><a href="/blog/post/html/./10.Rust笔记/Untitled.html" data-path="./10.Rust笔记/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./10.Rust笔记/Untitled 2.html" data-path="./10.Rust笔记/Untitled 2.md">Untitled 2</a></li><li><a href="/blog/post/html/./10.Rust笔记/Untitled 1.html" data-path="./10.Rust笔记/Untitled 1.md">Untitled 1</a></li><li><a href="/blog/post/html/./10.Rust笔记/sqlx.html" data-path="./10.Rust笔记/sqlx.md">sqlx</a></li><li><p>Rust 全栈</p><ul data-path="./10.Rust笔记/Rust 全栈"><li><a href="/blog/post/html/./10.Rust笔记/Rust 全栈/Untitled.html" data-path="./10.Rust笔记/Rust 全栈/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./10.Rust笔记/Rust 全栈/3. 后端.html" data-path="./10.Rust笔记/Rust 全栈/3. 后端.md">3. 后端</a></li><li><p>3. 后端.assets</p><ul data-path="./10.Rust笔记/Rust 全栈/3. 后端.assets"></ul></li></ul></li><li><a href="/blog/post/html/./10.Rust笔记/postgresql.html" data-path="./10.Rust笔记/postgresql.md">postgresql</a></li><li><a href="/blog/post/html/./10.Rust笔记/Dioxus-部署.html" data-path="./10.Rust笔记/Dioxus-部署.md">Dioxus-部署</a></li><li><a href="/blog/post/html/./10.Rust笔记/Dioxus FullStack.html" data-path="./10.Rust笔记/Dioxus FullStack.md">Dioxus FullStack</a></li><li><a href="/blog/post/html/./10.Rust笔记/1.html" data-path="./10.Rust笔记/1.md">1</a></li></ul></li><li><p>1.java笔记</p><ul data-path="./1.java笔记"><li><p>轮子</p><ul data-path="./1.java笔记/轮子"><li><p>img</p><ul data-path="./1.java笔记/轮子/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/轮子/5. fastjson.html" data-path="./1.java笔记/轮子/5. fastjson.md">5. fastjson</a></li><li><a href="/blog/post/html/./1.java笔记/轮子/4. mybatis-plus.html" data-path="./1.java笔记/轮子/4. mybatis-plus.md">4. mybatis-plus</a></li><li><a href="/blog/post/html/./1.java笔记/轮子/3. pagehelper.html" data-path="./1.java笔记/轮子/3. pagehelper.md">3. pagehelper</a></li><li><a href="/blog/post/html/./1.java笔记/轮子/2. common-lang3包.html" data-path="./1.java笔记/轮子/2. common-lang3包.md">2. common-lang3包</a></li><li><a href="/blog/post/html/./1.java笔记/轮子/1. common-io包.html" data-path="./1.java笔记/轮子/1. common-io包.md">1. common-io包</a></li></ul></li><li><p>读书笔记</p><ul data-path="./1.java笔记/读书笔记"><li><a href="/blog/post/html/./1.java笔记/读书笔记/未命名.html" data-path="./1.java笔记/读书笔记/未命名.md">未命名</a></li><li><p>《head first》笔记</p><ul data-path="./1.java笔记/读书笔记/《head first》笔记"><li><a href="/blog/post/html/./1.java笔记/读书笔记/《head first》笔记/2. 观察者模式.html" data-path="./1.java笔记/读书笔记/《head first》笔记/2. 观察者模式.md">2. 观察者模式</a></li><li><a href="/blog/post/html/./1.java笔记/读书笔记/《head first》笔记/1.策略模式+三个原则.html" data-path="./1.java笔记/读书笔记/《head first》笔记/1.策略模式+三个原则.md">1.策略模式+三个原则</a></li></ul></li></ul></li><li><p>电商项目</p><ul data-path="./1.java笔记/电商项目"><li><p>mylist</p><ul data-path="./1.java笔记/电商项目/mylist"><li><p>Documents</p><ul data-path="./1.java笔记/电商项目/mylist/Documents"></ul></li></ul></li><li><a href="/blog/post/html/./1.java笔记/电商项目/5..html" data-path="./1.java笔记/电商项目/5..md">5.</a></li><li><a href="/blog/post/html/./1.java笔记/电商项目/4. 功能.html" data-path="./1.java笔记/电商项目/4. 功能.md">4. 功能</a></li><li><a href="/blog/post/html/./1.java笔记/电商项目/3. 项目需求.html" data-path="./1.java笔记/电商项目/3. 项目需求.md">3. 项目需求</a></li><li><a href="/blog/post/html/./1.java笔记/电商项目/2. 项目结构搭建.html" data-path="./1.java笔记/电商项目/2. 项目结构搭建.md">2. 项目结构搭建</a></li><li><a href="/blog/post/html/./1.java笔记/电商项目/1. Mybatis-Plus持久层框架.html" data-path="./1.java笔记/电商项目/1. Mybatis-Plus持久层框架.md">1. Mybatis-Plus持久层框架</a></li></ul></li><li><p>框架</p><ul data-path="./1.java笔记/框架"><li><p>img</p><ul data-path="./1.java笔记/框架/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/框架/1.Dubbo框架.html" data-path="./1.java笔记/框架/1.Dubbo框架.md">1.Dubbo框架</a></li></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/架构图"></ul></li><li><p>思维导图</p><ul data-path="./1.java笔记/思维导图"></ul></li><li><p>前后端交互方式</p><ul data-path="./1.java笔记/前后端交互方式"><li><a href="/blog/post/html/./1.java笔记/前后端交互方式/5. 数据格式化方案.html" data-path="./1.java笔记/前后端交互方式/5. 数据格式化方案.md">5. 数据格式化方案</a></li><li><a href="/blog/post/html/./1.java笔记/前后端交互方式/4. 跨域解决方案.html" data-path="./1.java笔记/前后端交互方式/4. 跨域解决方案.md">4. 跨域解决方案</a></li><li><a href="/blog/post/html/./1.java笔记/前后端交互方式/3. url请求解决方案.html" data-path="./1.java笔记/前后端交互方式/3. url请求解决方案.md">3. url请求解决方案</a></li><li><a href="/blog/post/html/./1.java笔记/前后端交互方式/2. vue-与-controller.html" data-path="./1.java笔记/前后端交互方式/2. vue-与-controller.md">2. vue-与-controller</a></li><li><a href="/blog/post/html/./1.java笔记/前后端交互方式/1. jsp与servlet.html" data-path="./1.java笔记/前后端交互方式/1. jsp与servlet.md">1. jsp与servlet</a></li></ul></li><li><p>ppt课件</p><ul data-path="./1.java笔记/ppt课件"></ul></li><li><a href="/blog/post/html/./1.java笔记/microserver.html" data-path="./1.java笔记/microserver.md">microserver</a></li><li><p>java面试</p><ul data-path="./1.java笔记/java面试"><li><a href="/blog/post/html/./1.java笔记/java面试/1.面试题.html" data-path="./1.java笔记/java面试/1.面试题.md">1.面试题</a></li></ul></li><li><p>java调优</p><ul data-path="./1.java笔记/java调优"><li><p>Jprofiler</p><ul data-path="./1.java笔记/java调优/Jprofiler"><li><a href="/blog/post/html/./1.java笔记/java调优/Jprofiler/未命名.html" data-path="./1.java笔记/java调优/Jprofiler/未命名.md">未命名</a></li></ul></li></ul></li><li><p>java手写算法</p><ul data-path="./1.java笔记/java手写算法"><li><p>算法笔记</p><ul data-path="./1.java笔记/java手写算法/算法笔记"><li><a href="/blog/post/html/./1.java笔记/java手写算法/算法笔记/03.链表.html" data-path="./1.java笔记/java手写算法/算法笔记/03.链表.md">03.链表</a></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/算法笔记/02.队列.html" data-path="./1.java笔记/java手写算法/算法笔记/02.队列.md">02.队列</a></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/算法笔记/01.稀疏数组.html" data-path="./1.java笔记/java手写算法/算法笔记/01.稀疏数组.md">01.稀疏数组</a></li></ul></li><li><p>2.子字符串查找</p><ul data-path="./1.java笔记/java手写算法/2.子字符串查找"><li><a href="/blog/post/html/./1.java笔记/java手写算法/2.子字符串查找/5. 总结.html" data-path="./1.java笔记/java手写算法/2.子字符串查找/5. 总结.md">5. 总结</a></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/2.子字符串查找/4.Rabin-Karp.html" data-path="./1.java笔记/java手写算法/2.子字符串查找/4.Rabin-Karp.md">4.Rabin-Karp</a></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/2.子字符串查找/3. BoyerMoore.html" data-path="./1.java笔记/java手写算法/2.子字符串查找/3. BoyerMoore.md">3. BoyerMoore</a></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/2.子字符串查找/2. KMP.html" data-path="./1.java笔记/java手写算法/2.子字符串查找/2. KMP.md">2. KMP</a></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/2.子字符串查找/1. 暴力子字符串查找.html" data-path="./1.java笔记/java手写算法/2.子字符串查找/1. 暴力子字符串查找.md">1. 暴力子字符串查找</a></li></ul></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/2. 数据结构.html" data-path="./1.java笔记/java手写算法/2. 数据结构.md">2. 数据结构</a></li><li><p>1.手写排序</p><ul data-path="./1.java笔记/java手写算法/1.手写排序"><li><a href="/blog/post/html/./1.java笔记/java手写算法/1.手写排序/1. QuickSort快排.html" data-path="./1.java笔记/java手写算法/1.手写排序/1. QuickSort快排.md">1. QuickSort快排</a></li></ul></li><li><a href="/blog/post/html/./1.java笔记/java手写算法/1. 算法.html" data-path="./1.java笔记/java手写算法/1. 算法.md">1. 算法</a></li></ul></li><li><p>java后端</p><ul data-path="./1.java笔记/java后端"><li><p>高级</p><ul data-path="./1.java笔记/java后端/高级"><li><p>java类加载der</p><ul data-path="./1.java笔记/java后端/高级/java类加载der"><li><a href="/blog/post/html/./1.java笔记/java后端/高级/java类加载der/JVM堆内存设置原理.html" data-path="./1.java笔记/java后端/高级/java类加载der/JVM堆内存设置原理.md">JVM堆内存设置原理</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/高级/java类加载der/JVM内存与垃圾回收.html" data-path="./1.java笔记/java后端/高级/java类加载der/JVM内存与垃圾回收.md">JVM内存与垃圾回收</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/高级/java类加载der/JAVA类加载机制.html" data-path="./1.java笔记/java后端/高级/java类加载der/JAVA类加载机制.md">JAVA类加载机制</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/高级/java类加载der/img"></ul></li></ul></li></ul></li><li><p>面试题</p><ul data-path="./1.java笔记/java后端/面试题"><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/9"></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/8.分布式锁、事务"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/8-22.html" data-path="./1.java笔记/java后端/面试题/8-22.md">8-22</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/7月14日.html" data-path="./1.java笔记/java后端/面试题/7月14日.md">7月14日</a></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/7.Redis"></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/6.ES"></ul></li><li><p>5.MQ</p><ul data-path="./1.java笔记/java后端/面试题/5.MQ"><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/5.MQ/MQ.html" data-path="./1.java笔记/java后端/面试题/5.MQ/MQ.md">MQ</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/面试题/5.MQ/img"></ul></li></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/4.Dubbo"></ul></li><li><p>3.JVM</p><ul data-path="./1.java笔记/java后端/面试题/3.JVM"><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/3.JVM/Untitled Folder"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/3.JVM/jvm专题截图（未处理）.html" data-path="./1.java笔记/java后端/面试题/3.JVM/jvm专题截图（未处理）.md">jvm专题截图（未处理）</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/面试题/3.JVM/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/3.JVM/4. jvm面试题.html" data-path="./1.java笔记/java后端/面试题/3.JVM/4. jvm面试题.md">4. jvm面试题</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/3.JVM/4. jvm专题（总结）.html" data-path="./1.java笔记/java后端/面试题/3.JVM/4. jvm专题（总结）.md">4. jvm专题（总结）</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/3.JVM/3. 性能监控与调优.html" data-path="./1.java笔记/java后端/面试题/3.JVM/3. 性能监控与调优.md">3. 性能监控与调优</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/3.JVM/2. 字节码与类加载.html" data-path="./1.java笔记/java后端/面试题/3.JVM/2. 字节码与类加载.md">2. 字节码与类加载</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/3.JVM/1. 内存与垃圾回收.html" data-path="./1.java笔记/java后端/面试题/3.JVM/1. 内存与垃圾回收.md">1. 内存与垃圾回收</a></li></ul></li><li><p>2.MySql</p><ul data-path="./1.java笔记/java后端/面试题/2.MySql"><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/2.MySql/mysql索引面试准备.html" data-path="./1.java笔记/java后端/面试题/2.MySql/mysql索引面试准备.md">mysql索引面试准备</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/面试题/2.MySql/img"></ul></li><li><p>audio</p><ul data-path="./1.java笔记/java后端/面试题/2.MySql/audio"></ul></li></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/11"></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/面试题/10"></ul></li><li><p>1.HashMap</p><ul data-path="./1.java笔记/java后端/面试题/1.HashMap"><li><p>img</p><ul data-path="./1.java笔记/java后端/面试题/1.HashMap/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/面试题/1.HashMap/HashMap面试准备.html" data-path="./1.java笔记/java后端/面试题/1.HashMap/HashMap面试准备.md">HashMap面试准备</a></li></ul></li></ul></li><li><p>截图</p><ul data-path="./1.java笔记/java后端/截图"><li><p>算法截图</p><ul data-path="./1.java笔记/java后端/截图/算法截图"></ul></li><li><p>多线程截图</p><ul data-path="./1.java笔记/java后端/截图/多线程截图"></ul></li><li><p>单例</p><ul data-path="./1.java笔记/java后端/截图/单例"></ul></li><li><p>UML图</p><ul data-path="./1.java笔记/java后端/截图/UML图"></ul></li><li><p>Swing窗口</p><ul data-path="./1.java笔记/java后端/截图/Swing窗口"></ul></li></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/markdown手册.html" data-path="./1.java笔记/java后端/markdown手册.md">markdown手册</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/IDEA快捷键.html" data-path="./1.java笔记/java后端/IDEA快捷键.md">IDEA快捷键</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/day03.html" data-path="./1.java笔记/java后端/day03.md">day03</a></li><li><p>8.Log4J2</p><ul data-path="./1.java笔记/java后端/8.Log4J2"><li><a href="/blog/post/html/./1.java笔记/java后端/8.Log4J2/1.配置文件.html" data-path="./1.java笔记/java后端/8.Log4J2/1.配置文件.md">1.配置文件</a></li></ul></li><li><p>6.项目</p><ul data-path="./1.java笔记/java后端/6.项目"><li><a href="/blog/post/html/./1.java笔记/java后端/6.项目/泽林后台管理平台.html" data-path="./1.java笔记/java后端/6.项目/泽林后台管理平台.md">泽林后台管理平台</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/6.项目/2.Gradle构建工具.html" data-path="./1.java笔记/java后端/6.项目/2.Gradle构建工具.md">2.Gradle构建工具</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/6.项目/1.Maven构建工具.html" data-path="./1.java笔记/java后端/6.项目/1.Maven构建工具.md">1.Maven构建工具</a></li></ul></li><li><p>5.SSM框架</p><ul data-path="./1.java笔记/java后端/5.SSM框架"><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/搭建ssm框架.html" data-path="./1.java笔记/java后端/5.SSM框架/搭建ssm框架.md">搭建ssm框架</a></li><li><p>3.SpringMVC</p><ul data-path="./1.java笔记/java后端/5.SSM框架/3.SpringMVC"><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/3.SpringMVC/5.SpringMVC.html" data-path="./1.java笔记/java后端/5.SSM框架/3.SpringMVC/5.SpringMVC.md">5.SpringMVC</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/3.SpringMVC/4.SpringMVC核心应用.html" data-path="./1.java笔记/java后端/5.SSM框架/3.SpringMVC/4.SpringMVC核心应用.md">4.SpringMVC核心应用</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/3.SpringMVC/3.SpringMVC响应数据.html" data-path="./1.java笔记/java后端/5.SSM框架/3.SpringMVC/3.SpringMVC响应数据.md">3.SpringMVC响应数据</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/3.SpringMVC/2.SpringMVC参数传递.html" data-path="./1.java笔记/java后端/5.SSM框架/3.SpringMVC/2.SpringMVC参数传递.md">2.SpringMVC参数传递</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/3.SpringMVC/1.springMVC基本结构搭建.html" data-path="./1.java笔记/java后端/5.SSM框架/3.SpringMVC/1.springMVC基本结构搭建.md">1.springMVC基本结构搭建</a></li></ul></li><li><p>2.Spring框架</p><ul data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架"><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/9.Spring源码理解.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/9.Spring源码理解.md">9.Spring源码理解</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/8. 复习.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/8. 复习.md">8. 复习</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/7.Spring整合Mybatis.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/7.Spring整合Mybatis.md">7.Spring整合Mybatis</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/6.IOC和AOP.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/6.IOC和AOP.md">6.IOC和AOP</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/5. 代理模式与装饰器.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/5. 代理模式与装饰器.md">5. 代理模式与装饰器</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/4.切点表达式.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/4.切点表达式.md">4.切点表达式</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/3.AOP面向切面编程.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/3.AOP面向切面编程.md">3.AOP面向切面编程</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/2.IOC控制反转.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/2.IOC控制反转.md">2.IOC控制反转</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/2.Spring框架/1.简单工厂模式.html" data-path="./1.java笔记/java后端/5.SSM框架/2.Spring框架/1.简单工厂模式.md">1.简单工厂模式</a></li></ul></li><li><p>1.MyBatis框架</p><ul data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架"><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/6. 动态SQL.html" data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/6. 动态SQL.md">6. 动态SQL</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/5.resultMap结果映射.html" data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/5.resultMap结果映射.md">5.resultMap结果映射</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/4.Mybatis缓存机制.html" data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/4.Mybatis缓存机制.md">4.Mybatis缓存机制</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/3.sql映射文件参数传递.html" data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/3.sql映射文件参数传递.md">3.sql映射文件参数传递</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/2.mybatis核心对象.html" data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/2.mybatis核心对象.md">2.mybatis核心对象</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/1.mybatis配置.html" data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/1.mybatis配置.md">1.mybatis配置</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/1.html" data-path="./1.java笔记/java后端/5.SSM框架/1.MyBatis框架/1.md">1</a></li></ul></li></ul></li><li><p>4.JavaWeb</p><ul data-path="./1.java笔记/java后端/4.JavaWeb"><li><p>U4</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/U4"><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U4/UML线条箭头.html" data-path="./1.java笔记/java后端/4.JavaWeb/U4/UML线条箭头.md">UML线条箭头</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U4/Linux.html" data-path="./1.java笔记/java后端/4.JavaWeb/U4/Linux.md">Linux</a></li></ul></li><li><p>U3</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/U3"><li><p>img</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/U3/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/9.分页查询.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/9.分页查询.md">9.分页查询</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/8.案例删除role角色.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/8.案例删除role角色.md">8.案例删除role角色</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/7.service.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/7.service.md">7.service</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/6.JNDI线程池.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/6.JNDI线程池.md">6.JNDI线程池</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/5.properties配置文件.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/5.properties配置文件.md">5.properties配置文件</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/4.单例模式.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/4.单例模式.md">4.单例模式</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/3. DAO模式.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/3. DAO模式.md">3. DAO模式</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/21.修改案例.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/21.修改案例.md">21.修改案例</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/20.删除案例.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/20.删除案例.md">20.删除案例</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/2.JDBC.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/2.JDBC.md">2.JDBC</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/19.注册案例.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/19.注册案例.md">19.注册案例</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/18.增删改.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/18.增删改.md">18.增删改</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/17.查询基本功.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/17.查询基本功.md">17.查询基本功</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/16.JSON.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/16.JSON.md">16.JSON</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/14.MVC设计模式.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/14.MVC设计模式.md">14.MVC设计模式</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/13.监听器及MVC.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/13.监听器及MVC.md">13.监听器及MVC</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/12.Servlet与过滤器.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/12.Servlet与过滤器.md">12.Servlet与过滤器</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/11.JSTL标签库.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/11.JSTL标签库.md">11.JSTL标签库</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/10.EL表达式.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/10.EL表达式.md">10.EL表达式</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U3/1.javaweb.html" data-path="./1.java笔记/java后端/4.JavaWeb/U3/1.javaweb.md">1.javaweb</a></li></ul></li><li><p>U2</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/U2"><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U2/keyCode表.html" data-path="./1.java笔记/java后端/4.JavaWeb/U2/keyCode表.md">keyCode表</a></li><li><p>HTML和CSS</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/U2/HTML和CSS"><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U2/HTML和CSS/Untitled.html" data-path="./1.java笔记/java后端/4.JavaWeb/U2/HTML和CSS/Untitled.md">Untitled</a></li></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/U2/1. 页码页面跳转.html" data-path="./1.java笔记/java后端/4.JavaWeb/U2/1. 页码页面跳转.md">1. 页码页面跳转</a></li></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/3.超市订单管理项目"></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/2.MVC"></ul></li><li><p>1.web前端</p><ul data-path="./1.java笔记/java后端/4.JavaWeb/1.web前端"><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/1.web前端/Untitled.html" data-path="./1.java笔记/java后端/4.JavaWeb/1.web前端/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/4.JavaWeb/1.web前端/1.typeScript.html" data-path="./1.java笔记/java后端/4.JavaWeb/1.web前端/1.typeScript.md">1.typeScript</a></li></ul></li></ul></li><li><p>2.Java集合框架</p><ul data-path="./1.java笔记/java后端/2.Java集合框架"><li><a href="/blog/post/html/./1.java笔记/java后端/2.Java集合框架/集合框架面试题.html" data-path="./1.java笔记/java后端/2.Java集合框架/集合框架面试题.md">集合框架面试题</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/2.Java集合框架/img"></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/2.Java集合框架/3.集合类源码解析"></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/2.Java集合框架/2.非线程安全集合类"></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/2.Java集合框架/1.线程安全集合类"></ul></li></ul></li><li><p>18. Elasticsearch</p><ul data-path="./1.java笔记/java后端/18. Elasticsearch"><li><p>img</p><ul data-path="./1.java笔记/java后端/18. Elasticsearch/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/18. Elasticsearch/5. es+springboot手册.html" data-path="./1.java笔记/java后端/18. Elasticsearch/5. es+springboot手册.md">5. es+springboot手册</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/18. Elasticsearch/4. Elasticsearch入门.html" data-path="./1.java笔记/java后端/18. Elasticsearch/4. Elasticsearch入门.md">4. Elasticsearch入门</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/18. Elasticsearch/3. 本地部署和集群.html" data-path="./1.java笔记/java后端/18. Elasticsearch/3. 本地部署和集群.md">3. 本地部署和集群</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/18. Elasticsearch/2. 基本概念.html" data-path="./1.java笔记/java后端/18. Elasticsearch/2. 基本概念.md">2. 基本概念</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/18. Elasticsearch/1. 基本操作.html" data-path="./1.java笔记/java后端/18. Elasticsearch/1. 基本操作.md">1. 基本操作</a></li></ul></li><li><p>17.mybatis-plus</p><ul data-path="./1.java笔记/java后端/17.mybatis-plus"><li><a href="/blog/post/html/./1.java笔记/java后端/17.mybatis-plus/Untitled.html" data-path="./1.java笔记/java后端/17.mybatis-plus/Untitled.md">Untitled</a></li></ul></li><li><p>16.开源快速开发框架</p><ul data-path="./1.java笔记/java后端/16.开源快速开发框架"><li><p>undefined</p><ul data-path="./1.java笔记/java后端/16.开源快速开发框架/ruoyi"></ul></li><li><p>renren</p><ul data-path="./1.java笔记/java后端/16.开源快速开发框架/renren"><li><a href="/blog/post/html/./1.java笔记/java后端/16.开源快速开发框架/renren/1..html" data-path="./1.java笔记/java后端/16.开源快速开发框架/renren/1..md">1.</a></li></ul></li></ul></li><li><p>14.通用tkMapper</p><ul data-path="./1.java笔记/java后端/14.通用tkMapper"><li><a href="/blog/post/html/./1.java笔记/java后端/14.通用tkMapper/tkMapper笔记.html" data-path="./1.java笔记/java后端/14.通用tkMapper/tkMapper笔记.md">tkMapper笔记</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/14.通用tkMapper/img"></ul></li></ul></li><li><p>13. 加密和权限</p><ul data-path="./1.java笔记/java后端/13. 加密和权限"><li><a href="/blog/post/html/./1.java笔记/java后端/13. 加密和权限/数据加密、支付宝开放平台.html" data-path="./1.java笔记/java后端/13. 加密和权限/数据加密、支付宝开放平台.md">数据加密、支付宝开放平台</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/13. 加密和权限/img"></ul></li></ul></li><li><p>12.springboot</p><ul data-path="./1.java笔记/java后端/12.springboot"><li><a href="/blog/post/html/./1.java笔记/java后端/12.springboot/springboot面试题.html" data-path="./1.java笔记/java后端/12.springboot/springboot面试题.md">springboot面试题</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/12.springboot/Springboot源码分析.html" data-path="./1.java笔记/java后端/12.springboot/Springboot源码分析.md">Springboot源码分析</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/12.springboot/SpringBoot.html" data-path="./1.java笔记/java后端/12.springboot/SpringBoot.md">SpringBoot</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/12.springboot/img"></ul></li></ul></li><li><p>undefined</p><ul data-path="./1.java笔记/java后端/11.Zookkeeper"></ul></li><li><p>10.Redis</p><ul data-path="./1.java笔记/java后端/10.Redis"><li><a href="/blog/post/html/./1.java笔记/java后端/10.Redis/Redis.html" data-path="./1.java笔记/java后端/10.Redis/Redis.md">Redis</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/10.Redis/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/10.Redis/1..html" data-path="./1.java笔记/java后端/10.Redis/1..md">1.</a></li></ul></li><li><p>1.JavaSE基础</p><ul data-path="./1.java笔记/java后端/1.JavaSE基础"><li><p>1.Java语法</p><ul data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法"><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/Untitled.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/Untitled.md">Untitled</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/mysql索引面试准备.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/mysql索引面试准备.md">mysql索引面试准备</a></li><li><p>img</p><ul data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/img"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/HashMap面试准备.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/HashMap面试准备.md">HashMap面试准备</a></li><li><p>audio</p><ul data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/audio"></ul></li><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/5.基础（五）.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/5.基础（五）.md">5.基础（五）</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/4.基础（四）.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/4.基础（四）.md">4.基础（四）</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/3.基础（三）.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/3.基础（三）.md">3.基础（三）</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/2.基础（二）.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/2.基础（二）.md">2.基础（二）</a></li><li><a href="/blog/post/html/./1.java笔记/java后端/1.JavaSE基础/1.Java语法/1.基础（一）.html" data-path="./1.java笔记/java后端/1.JavaSE基础/1.Java语法/1.基础（一）.md">1.基础（一）</a></li></ul></li></ul></li></ul></li><li><p>javaFx桌面编程</p><ul data-path="./1.java笔记/javaFx桌面编程"><li><p>Swing</p><ul data-path="./1.java笔记/javaFx桌面编程/Swing"><li><a href="/blog/post/html/./1.java笔记/javaFx桌面编程/Swing/04Hutool数据库.html" data-path="./1.java笔记/javaFx桌面编程/Swing/04Hutool数据库.md">04Hutool数据库</a></li><li><a href="/blog/post/html/./1.java笔记/javaFx桌面编程/Swing/03按钮事件.html" data-path="./1.java笔记/javaFx桌面编程/Swing/03按钮事件.md">03按钮事件</a></li><li><a href="/blog/post/html/./1.java笔记/javaFx桌面编程/Swing/02登录功能.html" data-path="./1.java笔记/javaFx桌面编程/Swing/02登录功能.md">02登录功能</a></li><li><a href="/blog/post/html/./1.java笔记/javaFx桌面编程/Swing/01窗口创建.html" data-path="./1.java笔记/javaFx桌面编程/Swing/01窗口创建.md">01窗口创建</a></li></ul></li><li><p>Fx</p><ul data-path="./1.java笔记/javaFx桌面编程/Fx"><li><a href="/blog/post/html/./1.java笔记/javaFx桌面编程/Fx/入门.html" data-path="./1.java笔记/javaFx桌面编程/Fx/入门.md">入门</a></li></ul></li></ul></li><li><p>img</p><ul data-path="./1.java笔记/img"></ul></li><li><p>Apache-Nifi技术</p><ul data-path="./1.java笔记/Apache-Nifi技术"><li><a href="/blog/post/html/./1.java笔记/Apache-Nifi技术/1. Nifi安装.html" data-path="./1.java笔记/Apache-Nifi技术/1. Nifi安装.md">1. Nifi安装</a></li></ul></li></ul></li></ul></li></ul></div>
        </div>
        <div id="left-section5">
          <span>案例</span>
          <ul>
            <li>demo 1</li>
          </ul>
        </div>
      </div>
      <div id="center">
        <div id="content"><h1>概念</h1>
<p>本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。</p>
<h6>提示</h6>
<p>可以在 这里 了解更多关于 JavaScript 模块和 webpack 模块的信息。</p>
<p>从 v4.0.0 开始，webpack 可以不用再引入一个配置文件来打包项目，然而，它仍然有着 高度可配置性，可以很好满足你的需求。</p>
<p>在开始前你需要先理解一些核心概念：</p>
<ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugin)</li>
<li>模式(mode)</li>
<li>浏览器兼容性(browser compatibility)</li>
<li>环境(environment)</li>
</ul>
<p>本文档旨在给出这些概念的高度概述，同时提供具体概念的详尽相关用例的链接。</p>
<p>为了更好地理解模块打包工具背后的理念，以及在底层它们是如何运作的，请参考以下资源：</p>
<ul>
<li>手动打包一个应用程序</li>
<li>实时创建一个简单打包工具</li>
<li>一个简单打包工具的详细说明</li>
</ul>
<h2>入口(entry)</h2>
<p>入口起点(entry point) 指示 webpack 应该使用哪个模块，来作为构建其内部 依赖图(dependency graph) 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>
<p>默认值是 ./src/index.js，但你可以通过在 webpack configuration 中配置 entry 属性，来指定一个（或多个）不同的入口起点。例如：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./path/to/my/entry/file.js'</span>,
};
</code></pre><h6>提示</h6>
<p>在 入口起点 章节可以了解更多信息。</p>
<h2>输出(output)</h2>
<p>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。</p>
<p>你可以通过在配置中指定一个 output 字段，来配置这些处理过程：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./path/to/my/entry/file.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'my-first-webpack.bundle.js'</span>,
  },
};
</code></pre><p>在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 Node.js 核心模块，用于操作文件路径。</p>
<h6>提示</h6>
<p>output 属性还有 更多可配置的特性，如果你想要了解更多关于 output 属性的概念，可以通过阅读 输出章节 来了解更多。</p>
<h2>loader</h2>
<p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。</p>
<h6>警告</h6>
<p>webpack 的其中一个强大的特性就是能通过 import 导入任何类型的模块（例如 .css 文件），其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是很有必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p>
<p>在更高层面，在 webpack 的配置中，loader 有两个属性：</p>
<ol>
<li>test 属性，识别出哪些文件会被转换。</li>
<li>use 属性，定义出在进行转换时，应该使用哪个 loader。</li>
</ol>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'my-first-webpack.bundle.js'</span>,
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [{ <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'raw-loader'</span> }],
  },
};
</code></pre><p>以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息：</p>
<blockquote>
<p>“嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 '.txt' 的路径」时，在你对它打包之前，先 use(使用) raw-loader 转换一下。”</p>
</blockquote>
<h6>警告</h6>
<p>重要的是要记住，在 webpack 配置中定义 rules 时，要定义在 module.rules 而不是 rules 中。为了使你便于理解，如果没有按照正确方式去做，webpack 会给出警告。</p>
<h6>警告</h6>
<p>请记住，使用正则表达式匹配文件时，你不要为它添加引号。也就是说，/.txt/ 与 '/.txt/' 或 "/.txt$/" 不一样。前者指示 webpack 匹配任何以 .txt 结尾的文件，后者指示 webpack 匹配具有绝对路径 '.txt' 的单个文件; 这可能不符合你的意图。</p>
<p>在使用 loader 时，可以阅读 loader 章节 查看更深入的自定义配置。</p>
<h2>插件(plugin)</h2>
<p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p>
<h6>提示</h6>
<p>查看 插件接口(plugin interface)，学习如何使用它来扩展 webpack 能力。</p>
<p>想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例。</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>); <span class="hljs-comment">// 用于访问内置插件</span>

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [{ <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.txt$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'raw-loader'</span> }],
  },
  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({ <span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.html'</span> })],
};
</code></pre><p>在上面的示例中，html-webpack-plugin 为应用程序生成一个 HTML 文件，并自动将生成的所有 bundle 注入到此文件中。</p>
<h6>提示</h6>
<p>webpack 提供许多开箱可用的插件！查阅 插件列表 获取更多。</p>
<p>在 webpack 配置中使用插件是简单直接的。然而，也有很多值得我们进一步探讨的用例。查看这里了解更多。</p>
<h2>模式(mode)</h2>
<p>通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
};
</code></pre><p>想要了解更多，请查阅 mode 配置，这里有具体每个值相应的优化行为。</p>
<h2>浏览器兼容性(browser compatibility)</h2>
<p>Webpack 支持所有符合 ES5 标准 的浏览器（不支持 IE8 及以下版本）。webpack 的 import() 和 require.ensure() 需要 Promise。如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要 提前加载 polyfill。</p>
<h2>环境(environment)</h2>
<p>Webpack 5 运行于 Node.js v10.13.0+ 的版本。</p>
<h1>入口起点(entry points)</h1>
<p>正如我们在 起步 中提到的，在 webpack 配置中有多种方式定义 entry 属性。除了解释为什么它可能非常有用，我们还将向你展示如何去配置 entry 属性。</p>
<h2>单个入口（简写）语法</h2>
<p>用法：entry: string | [string]</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./path/to/my/entry/file.js'</span>,
};
</code></pre><p>entry 属性的单个入口语法，是以下形式的简写：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./path/to/my/entry/file.js'</span>,
  },
};
</code></pre><p>我们也可以将一个文件路径数组传递给 entry 属性，这将创建一个所谓的 "multi-main entry"。在你想要一次注入多个依赖文件，并且将它们的依赖关系绘制在一个 "chunk" 中时，这种方式就很有用。</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: [<span class="hljs-string">'./src/file_1.js'</span>, <span class="hljs-string">'./src/file_2.js'</span>],
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
  },
};
</code></pre><p>当你希望通过一个入口（例如一个库）为应用程序或工具快速设置 webpack 配置时，单一入口的语法方式是不错的选择。然而，使用这种语法方式来扩展或调整配置的灵活性不大。</p>
<h2>对象语法</h2>
<p>用法：entry: { <entrychunkname> string | [string] } | {}</entrychunkname></p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">app</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">adminApp</span>: <span class="hljs-string">'./src/adminApp.js'</span>,
  },
};
</code></pre><p>对象语法会比较繁琐。然而，这是应用程序中定义入口的最可扩展的方式。</p>
<h6>提示</h6>
<p>“webpack 配置的可扩展” 是指，这些配置可以重复使用，并且可以与其他配置组合使用。这是一种流行的技术，用于将关注点从环境(environment)、构建目标(build target)、运行时(runtime)中分离。然后使用专门的工具（如 webpack-merge）将它们合并起来。</p>
<h6>提示</h6>
<p>当你通过插件生成入口时，你可以传递空对象 {} 给 entry。</p>
<h3>描述入口的对象</h3>
<p>用于描述入口的对象。你可以使用如下属性：</p>
<ul>
<li>dependOn: 当前入口所依赖的入口。它们必须在该入口被加载前被加载。</li>
<li>filename: 指定要输出的文件名称。</li>
<li>import: 启动时需加载的模块。</li>
<li>library: 指定 library 选项，为当前 entry 构建一个 library。</li>
<li>runtime: 运行时 chunk 的名字。如果设置了，就会创建一个新的运行时 chunk。在 webpack 5.43.0 之后可将其设为 false 以避免一个新的运行时 chunk。</li>
<li>publicPath: 当该入口的输出文件在浏览器中被引用时，为它们指定一个公共 URL 地址。请查看 output.publicPath。</li>
</ul>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">a2</span>: <span class="hljs-string">'dependingfile.js'</span>,
    <span class="hljs-attr">b2</span>: {
      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">'a2'</span>,
      <span class="hljs-attr">import</span>: <span class="hljs-string">'./src/app.js'</span>,
    },
  },
};
</code></pre><p>runtime 和 dependOn 不应在同一个入口上同时使用，所以如下配置无效，并且会抛出错误：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">a2</span>: <span class="hljs-string">'./a'</span>,
    <span class="hljs-attr">b2</span>: {
      <span class="hljs-attr">runtime</span>: <span class="hljs-string">'x2'</span>,
      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">'a2'</span>,
      <span class="hljs-attr">import</span>: <span class="hljs-string">'./b'</span>,
    },
  },
};
</code></pre><p>确保 runtime 不能指向已存在的入口名称，例如下面配置会抛出一个错误：</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">a1</span>: <span class="hljs-string">'./a'</span>,
    <span class="hljs-attr">b1</span>: {
      <span class="hljs-attr">runtime</span>: <span class="hljs-string">'a1'</span>,
      <span class="hljs-attr">import</span>: <span class="hljs-string">'./b'</span>,
    },
  },
};
</code></pre><p>另外 dependOn 不能是循环引用的，下面的例子也会出现错误：</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">a3</span>: {
      <span class="hljs-attr">import</span>: <span class="hljs-string">'./a'</span>,
      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">'b3'</span>,
    },
    <span class="hljs-attr">b3</span>: {
      <span class="hljs-attr">import</span>: <span class="hljs-string">'./b'</span>,
      <span class="hljs-attr">dependOn</span>: <span class="hljs-string">'a3'</span>,
    },
  },
};
</code></pre><h2>常见场景</h2>
<p>以下列出一些入口配置和它们的实际用例：</p>
<h3>分离 app(应用程序) 和 vendor(第三方库) 入口</h3>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">main</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">vendor</span>: <span class="hljs-string">'./src/vendor.js'</span>,
  },
};
</code></pre><p>webpack.prod.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].[contenthash].bundle.js'</span>,
  },
};
</code></pre><p>webpack.dev.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].bundle.js'</span>,
  },
};
</code></pre><p>这是什么？ 这是告诉 webpack 我们想要配置 2 个单独的入口点（例如上面的示例）。</p>
<p>为什么？ 这样你就可以在 vendor.js 中存入未做修改的必要 library 或文件（例如 Bootstrap, jQuery, 图片等），然后将它们打包在一起成为单独的 chunk。内容哈希保持不变，这使浏览器可以独立地缓存它们，从而减少了加载时间。</p>
<h6>提示</h6>
<p>在 webpack &lt; 4 的版本中，通常将 vendor 作为一个单独的入口起点添加到 entry 选项中，以将其编译为一个单独的文件（与 CommonsChunkPlugin 结合使用）。</p>
<p>而在 webpack 4 中不鼓励这样做。而是使用 optimization.splitChunks 选项，将 vendor 和 app(应用程序) 模块分开，并为其创建一个单独的文件。不要 为 vendor 或其他不是执行起点创建 entry。</p>
<h3>多页面应用程序</h3>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">pageOne</span>: <span class="hljs-string">'./src/pageOne/index.js'</span>,
    <span class="hljs-attr">pageTwo</span>: <span class="hljs-string">'./src/pageTwo/index.js'</span>,
    <span class="hljs-attr">pageThree</span>: <span class="hljs-string">'./src/pageThree/index.js'</span>,
  },
};
</code></pre><p>这是什么？ 我们告诉 webpack 需要三个独立分离的依赖图（如上面的示例）。</p>
<p>为什么？ 在多页面应用程序中，server 会拉取一个新的 HTML 文档给你的客户端。页面重新加载此新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事，例如使用 optimization.splitChunks 为页面间共享的应用程序代码创建 bundle。由于入口起点数量的增多，多页应用能够复用多个入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</p>
<h6>提示</h6>
<p>根据经验：每个 HTML 文档只使用一个入口起点。具体原因请参阅此 issue。</p>
<h1>输出(output)</h1>
<p>可以通过配置 output 选项，告知 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个 entry 起点，但只能指定一个 output 配置。</p>
<h2>用法</h2>
<p>在 webpack 配置中，output 属性的最低要求是，将它的值设置为一个对象，然后为将输出文件的文件名配置为一个 output.filename：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'bundle.js'</span>,
  },
};
</code></pre><p>此配置将一个单独的 bundle.js 文件输出到 dist 目录中。</p>
<h2>多个入口起点</h2>
<p>如果配置中创建出多于一个 "chunk"（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用 占位符(substitutions) 来确保每个文件具有唯一的名称。</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">app</span>: <span class="hljs-string">'./src/app.js'</span>,
    <span class="hljs-attr">search</span>: <span class="hljs-string">'./src/search.js'</span>,
  },
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].js'</span>,
    <span class="hljs-attr">path</span>: __dirname + <span class="hljs-string">'/dist'</span>,
  },
};

<span class="hljs-comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span>
</code></pre><h2>高级进阶</h2>
<p>以下是对资源使用 CDN 和 hash 的复杂示例：</p>
<p>config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">//...</span>
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'/home/proj/cdn/assets/[fullhash]'</span>,
    <span class="hljs-attr">publicPath</span>: <span class="hljs-string">'https://cdn.example.com/assets/[fullhash]/'</span>,
  },
};
</code></pre><p>如果在编译时，不知道最终输出文件的 publicPath 是什么地址，则可以将其留空，并且在运行时通过入口起点文件中的 webpack_public_path 动态设置。</p>
<pre><code class="hljs language-javascript">__webpack_public_path__ = myRuntimePublicPath;

<span class="hljs-comment">// 应用程序入口的其余部分</span>
</code></pre><h1>loader</h1>
<p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或 "load(加载)" 模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的得力方式。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript 或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS 文件！</p>
<h2>示例</h2>
<p>例如，你可以使用 loader 告诉 webpack 加载 CSS 文件，或者将 TypeScript 转为 JavaScript。为此，首先安装相对应的 loader：</p>
<pre><code class="hljs language-bash">npm install --save-dev css-loader ts-loader
</code></pre><p>然后指示 webpack 对每个 .css 使用 css-loader，以及对所有 .ts 文件使用 ts-loader：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'css-loader'</span> },
      { <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.ts$/</span>, <span class="hljs-attr">use</span>: <span class="hljs-string">'ts-loader'</span> },
    ],
  },
};
</code></pre><h2>使用 loader</h2>
<p>在你的应用程序中，有两种使用 loader 的方式：</p>
<ul>
<li>配置方式（推荐）：在 webpack.config.js 文件中指定 loader。</li>
<li>内联方式：在每个 import 语句中显式指定 loader。</li>
</ul>
<p>注意在 webpack v4 版本可以通过 CLI 使用 loader，但是在 webpack v5 中被弃用。</p>
<h3>Configuration</h3>
<p>module.rules 允许你在 webpack 配置中指定多个 loader。 这种方式是展示 loader 的一种简明方式，并且有助于使代码变得简洁和易于维护。同时让你对各个 loader 有个全局概览：</p>
<p>loader 从右到左（或从下到上）地取值(evaluate)/执行(execute)。在下面的示例中，从 sass-loader 开始执行，然后继续执行 css-loader，最后以 style-loader 为结束。查看 loader 功能 章节，了解有关 loader 顺序的更多信息。</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,
        <span class="hljs-attr">use</span>: [
          { <span class="hljs-attr">loader</span>: <span class="hljs-string">'style-loader'</span> },
          {
            <span class="hljs-attr">loader</span>: <span class="hljs-string">'css-loader'</span>,
            <span class="hljs-attr">options</span>: {
              <span class="hljs-attr">modules</span>: <span class="hljs-literal">true</span>,
            },
          },
          { <span class="hljs-attr">loader</span>: <span class="hljs-string">'sass-loader'</span> },
        ],
      },
    ],
  },
};
</code></pre><h3>内联方式</h3>
<p>可以在 import 语句或任何 与 "import" 方法同等的引用方式 中指定 loader。使用 ! 将资源中的 loader 分开。每个部分都会相对于当前目录解析。</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'style-loader!css-loader?modules!./styles.css'</span>;
</code></pre><p>通过为内联 import 语句添加前缀，可以覆盖 配置 中的所有 loader, preLoader 和 postLoader：</p>
<ul>
<li><p>使用 ! 前缀，将禁用所有已配置的 normal loader(普通 loader)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'!style-loader!css-loader?modules!./styles.css'</span>;
</code></pre></li>
<li><p>使用 !! 前缀，将禁用所有已配置的 loader（preLoader, loader, postLoader）</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'!!style-loader!css-loader?modules!./styles.css'</span>;
</code></pre></li>
<li><p>使用 -! 前缀，将禁用所有已配置的 preLoader 和 loader，但是不禁用 postLoaders</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Styles</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'-!style-loader!css-loader?modules!./styles.css'</span>;
</code></pre></li>
</ul>
<p>选项可以传递查询参数，例如 ?key=value&amp;foo=bar，或者一个 JSON 对象，例如 ?{"key":"value","foo":"bar"}。</p>
<h6>提示</h6>
<p>尽可能使用 module.rules，因为这样可以减少源码中样板文件的代码量，并且可以在出错时，更快地调试和定位 loader 中的问题。</p>
<h2>loader 特性</h2>
<ul>
<li>loader 支持链式调用。链中的每个 loader 会将转换应用在已处理过的资源上。一组链式的 loader 将按照相反的顺序执行。链中的第一个 loader 将其结果（也就是应用过转换后的资源）传递给下一个 loader，依此类推。最后，链中的最后一个 loader，返回 webpack 所期望的 JavaScript。</li>
<li>loader 可以是同步的，也可以是异步的。</li>
<li>loader 运行在 Node.js 中，并且能够执行任何操作。</li>
<li>loader 可以通过 options 对象配置（仍然支持使用 query 参数来设置选项，但是这种方式已被废弃）。</li>
<li>除了常见的通过 package.json 的 main 来将一个 npm 模块导出为 loader，还可以在 module.rules 中使用 loader 字段直接引用一个模块。</li>
<li>插件(plugin)可以为 loader 带来更多特性。</li>
<li>loader 能够产生额外的任意文件。</li>
</ul>
<p>可以通过 loader 的预处理函数，为 JavaScript 生态系统提供更多能力。用户现在可以更加灵活地引入细粒度逻辑，例如：压缩、打包、语言转译（或编译）和 更多其他特性。</p>
<h2>解析 loader</h2>
<p>loader 遵循标准 模块解析 规则。多数情况下，loader 将从 模块路径 加载（通常是从 npm install, node_modules 进行加载）。</p>
<p>我们预期 loader 模块导出为一个函数，并且编写为 Node.js 兼容的 JavaScript。通常使用 npm 进行管理 loader，但是也可以将应用程序中的文件作为自定义 loader。按照约定，loader 通常被命名为 xxx-loader（例如 json-loader）。更多详细信息，请查看 编写一个 loader。</p>
<h1>plugin</h1>
<p><strong>插件</strong> 是 webpack 的 <a href="https://github.com/webpack/tapable">支柱</a> 功能。Webpack 自身也是构建于你在 webpack 配置中用到的 <strong>相同的插件系统</strong> 之上！</p>
<p>插件目的在于解决 <a href="https://webpack.docschina.org/concepts/loaders">loader</a> 无法实现的<strong>其他事</strong>。Webpack 提供很多开箱即用的 <a href="https://webpack.docschina.org/plugins/">插件</a>。</p>
<h6>提示</h6>
<p>如果在插件中使用了 <a href="https://github.com/webpack/webpack-sources"><code>webpack-sources</code></a> 的 package，请使用 <code>require('webpack').sources</code> 替代 <code>require('webpack-sources')</code>，以避免持久缓存的版本冲突。</p>
<h2>剖析</h2>
<p>webpack <strong>插件</strong>是一个具有 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply</code></a> 方法的 JavaScript 对象。<code>apply</code> 方法会被 webpack compiler 调用，并且在 <strong>整个</strong> 编译生命周期都可以访问 compiler 对象。</p>
<p><strong>ConsoleLogOnBuildWebpackPlugin.js</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> pluginName = <span class="hljs-string">'ConsoleLogOnBuildWebpackPlugin'</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLogOnBuildWebpackPlugin</span> {
  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) {
    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">run</span>.<span class="hljs-title function_">tap</span>(pluginName, <span class="hljs-function">(<span class="hljs-params">compilation</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'webpack 构建正在启动！'</span>);
    });
  }
}

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-title class_">ConsoleLogOnBuildWebpackPlugin</span>;
</code></pre><p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中重复使用。</p>
<h2>用法</h2>
<p>由于<strong>插件</strong>可以携带参数/选项，你必须在 webpack 配置中，向 <code>plugins</code> 属性传入一个 <code>new</code> 实例。</p>
<p>取决于你的 webpack 用法，对应有多种使用插件的方式。</p>
<h3>配置方式</h3>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);
<span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>); <span class="hljs-comment">// 访问内置的插件</span>
<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./path/to/my/entry/file.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'my-first-webpack.bundle.js'</span>,
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
  },
  <span class="hljs-attr">module</span>: {
    <span class="hljs-attr">rules</span>: [
      {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|jsx)$/</span>,
        <span class="hljs-attr">use</span>: <span class="hljs-string">'babel-loader'</span>,
      },
    ],
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProgressPlugin</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({ <span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.html'</span> }),
  ],
};
</code></pre><p><code>ProgressPlugin</code> 用于自定义编译过程中的进度报告，<code>HtmlWebpackPlugin</code> 将生成一个 HTML 文件，并在其中使用 <code>script</code> 引入一个名为 <code>my-first-webpack.bundle.js</code> 的 JS 文件。</p>
<h3>Node API 方式</h3>
<p>在使用 Node API 时，还可以通过配置中的 <code>plugins</code> 属性传入插件。</p>
<p><strong>some-node-script.js</strong></p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>); <span class="hljs-comment">// 访问 webpack 运行时(runtime)</span>
<span class="hljs-keyword">const</span> configuration = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./webpack.config.js'</span>);

<span class="hljs-keyword">let</span> compiler = <span class="hljs-title function_">webpack</span>(configuration);

<span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">ProgressPlugin</span>().<span class="hljs-title function_">apply</span>(compiler);

compiler.<span class="hljs-title function_">run</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">err, stats</span>) {
  <span class="hljs-comment">// ...</span>
});
</code></pre><h6>提示</h6>
<p>你知道吗：以上看到的示例和 <a href="https://github.com/webpack/webpack/blob/e7087ffeda7fa37dfe2ca70b5593c6e899629a2c/bin/webpack.js#L290-L292">webpack 运行时(runtime)本身</a> 极其类似。<a href="https://github.com/webpack/webpack">webpack 源码</a> 中隐藏有大量使用示例，你可以将其应用在自己的配置和脚本中。</p>
<h1>配置（Configuration）</h1>
<p>你可能已经注意到，很少有 webpack 配置看起来完全相同。这是因为 webpack 的配置文件是 JavaScript 文件，文件内导出了一个 webpack 配置的对象。 webpack 会根据该配置定义的属性进行处理。</p>
<p>由于 webpack 遵循 CommonJS 模块规范，因此，你可以在配置中使用：</p>
<ul>
<li>通过 require(...) 引入其他文件</li>
<li>通过 require(...) 使用 npm 下载的工具函数</li>
<li>使用 JavaScript 控制流表达式，例如 ?: 操作符</li>
<li>对 value 使用常量或变量赋值</li>
<li>编写并执行函数，生成部分配置</li>
</ul>
<p>请在合适的场景，使用这些功能。</p>
<p>虽然技术上可行，但还是应避免如下操作：</p>
<ul>
<li>当使用 webpack CLI 工具时，访问 CLI 参数（应编写自己的 CLI 工具替代，或者使用 --env）</li>
<li>导出不确定的结果（两次调用 webpack 应产生相同的输出文件）</li>
<li>编写超长的配置（应将配置文件拆分成多个）</li>
</ul>
<h6>提示</h6>
<p>此文档中得出最重要的结论是，webpack 的配置可以有许多不同的样式和风格。关键在于，为了易于维护和理解这些配置，需要在团队内部保证一致。</p>
<p>接下来的示例中，展示了 webpack 配置如何实现既可表达，又可灵活配置，这主要得益于 配置即为代码：</p>
<h2>基本配置</h2>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'development'</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./foo.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'foo.bundle.js'</span>,
  },
};
</code></pre><h2>导出多种配置</h2>
<p>除了导出单个配置对象/函数，你可能也会需要导出多种配置（webpack 3.1.0 起支持）。当运行 webpack 时，所有配置项都会构建。比如，对于多 targets（如 AMD 和 CommonJS）构建 library 时会非常有用。</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [
  {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'./dist-amd.js'</span>,
      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">'amd'</span>,
    },
    <span class="hljs-attr">name</span>: <span class="hljs-string">'amd'</span>,
    <span class="hljs-attr">entry</span>: <span class="hljs-string">'./app.js'</span>,
    <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  },
  {
    <span class="hljs-attr">output</span>: {
      <span class="hljs-attr">filename</span>: <span class="hljs-string">'./dist-commonjs.js'</span>,
      <span class="hljs-attr">libraryTarget</span>: <span class="hljs-string">'commonjs'</span>,
    },
    <span class="hljs-attr">name</span>: <span class="hljs-string">'commonjs'</span>,
    <span class="hljs-attr">entry</span>: <span class="hljs-string">'./app.js'</span>,
    <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  },
];
</code></pre><h6>提示</h6>
<p>如果你只传了一个 --config-name 名字标识，webpack 将只会构建指定的配置项。</p>
<h2>使用其它配置语言</h2>
<p>Webpack 支持由多种编程和数据语言编写的配置文件。</p>
<h2>TypeScript</h2>
<p>要使用 Typescript 来编写 webpack 配置，你需要先安装必要的依赖，比如 Typescript 以及其相应的类型声明，类型声明可以从 DefinitelyTyped 项目中获取，依赖安装如下所示：</p>
<pre><code class="hljs language-bash">npm install --save-dev typescript ts-node @types/node @types/webpack
<span class="hljs-comment"># 如果使用版本低于 v4.7.0 的 webpack-dev-server，还需要安装以下依赖</span>
npm install --save-dev @types/webpack-dev-server
</code></pre><p>完成依赖安装后便可以开始编写配置文件，示例如下：</p>
<p>webpack.config.ts</p>
<pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>;
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> webpack <span class="hljs-keyword">from</span> <span class="hljs-string">'webpack'</span>;
<span class="hljs-comment">// in case you run into any typescript error when configuring `devServer`</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'webpack-dev-server'</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">config</span>: webpack.<span class="hljs-property">Configuration</span> = {
  <span class="hljs-attr">mode</span>: <span class="hljs-string">'production'</span>,
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./foo.js'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'foo.bundle.js'</span>,
  },
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> config;
</code></pre><p>该示例需要 typescript 版本在 2.7 及以上，并在 tsconfig.json 文件的 compilerOptions 中添加 esModuleInterop 和 allowSyntheticDefaultImports 两个配置项。</p>
<p>值得注意的是你需要确保 tsconfig.json 的 compilerOptions 中 module 选项的值为 commonjs,否则 webpack 的运行会失败报错，因为 ts-node 不支持 commonjs 以外的其他模块规范。</p>
<p>你可以通过三个途径来完成 module 的设置：</p>
<ul>
<li>直接修改 tsconfig.json 文件</li>
<li>修改 tsconfig.json 并且添加 ts-node 的设置。</li>
<li>使用 tsconfig-paths</li>
</ul>
<p>第一种方法就是打开你的 tsconfig.json 文件，找到 compilerOptions 的配置，然后设置 target 和 module 的选项分别为 "ES5" 和 "CommonJs" (在 target 设置为 es5 时你也可以不显示编写 module 配置)。</p>
<p>第二种方法 就是添加 ts-node 设置：</p>
<p>你可以为 tsc 保持 "module": "ESNext"配置，如果你是用 webpack 或者其他构建工具的话，为 ts-node 设置一个重载（override）。ts-node 配置项</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"ESNext"</span>
  <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
  <span class="hljs-attr">"ts-node"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
      <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"CommonJS"</span>
    <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><p>第三种方法需要先安装 tsconfig-paths 这个 npm 包，如下所示：</p>
<pre><code class="hljs language-bash">npm install --save-dev tsconfig-paths
</code></pre><p>安装后你可以为 webpack 配置创建一个单独的 TypeScript 配置文件，示例如下：</p>
<p>tsconfig-for-webpack-config.json</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"compilerOptions"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"module"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"commonjs"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"target"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"es5"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"esModuleInterop"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><h6>提示</h6>
<p>ts-node 可以根据 tsconfig-paths 提供的环境变量 process.env.TS_NODE_PROJECT 来找到 tsconfig.json 文件路径。</p>
<p>process.env.TS_NODE_PROJECT 变量的设置如下所示:</p>
<p>package.json</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"scripts"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"build"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"cross-env TS_NODE_PROJECT=\"tsconfig-for-webpack-config.json\" webpack"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>
</code></pre><p>之所以要添加 cross-env，是因为我们在直接使用 TS_NODE_PROJECT 时遇到过 "TS_NODE_PROJECT" unrecognized command 报错的反馈，添加 cross-env 之后该问题也似乎得到了解决，你可以查看这个 issue获取到关于该问题的更多信息。</p>
<h1>模块（Modules）</h1>
<p>在模块化编程中，开发者将程序分解为功能离散的 chunk，并称之为 模块。</p>
<p>每个模块都拥有小于完整程序的体积，使得验证、调试及测试变得轻而易举。 精心编写的 模块 提供了可靠的抽象和封装界限，使得应用程序中每个模块都具备了条理清晰的设计和明确的目的。</p>
<p>Node.js 从一开始就支持模块化编程。 然而，web 的 模块化 正在缓慢支持中。 在 web 界存在多种支持 JavaScript 模块化的工具，这些工具各有优势和限制。 Webpack 从这些系统中汲取了经验和教训，并将 模块 的概念应用到项目的任何文件中。</p>
<h2>何为 webpack 模块</h2>
<p>与 Node.js 模块相比，webpack 模块能以各种方式表达它们的依赖关系。下面是一些示例：</p>
<ul>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>stylesheet url(...) 或者 HTML <img src="..."> 文件中的图片链接。</li>
</ul>
<h2>支持的模块类型</h2>
<p>Webpack 天生支持如下模块类型：</p>
<ul>
<li>ECMAScript 模块</li>
<li>CommonJS 模块</li>
<li>AMD 模块</li>
<li>Assets</li>
<li>WebAssembly 模块</li>
</ul>
<p>通过 loader 可以使 webpack 支持多种语言和预处理器语法编写的模块。loader 向 webpack 描述了如何处理非原生 模块，并将相关依赖引入到你的 bundles中。 webpack 社区已经为各种流行的语言和预处理器创建了 loader，其中包括：</p>
<ul>
<li>CoffeeScript</li>
<li>TypeScript</li>
<li>ESNext (Babel)</li>
<li>Sass</li>
<li>Less</li>
<li>Stylus</li>
<li>Elm</li>
</ul>
<p>当然还有更多！总得来说，webpack 提供了可定制，强大且丰富的 API，允许在 任何技术栈 中使用，同时支持在开发、测试和生产环境的工作流中做到 无侵入性。</p>
<p>关于 loader 的相关信息，请参考 loader 列表 或 自定义 loader。</p>
<h1>模块解析（Module Resolution）</h1>
<p>resolver 是一个帮助寻找模块绝对路径的库。 一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> foo <span class="hljs-keyword">from</span> <span class="hljs-string">'path/to/module'</span>;
<span class="hljs-comment">// 或者</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">'path/to/module'</span>);
</code></pre><p>所依赖的模块可以是来自应用程序的代码或第三方库。 resolver 帮助 webpack 从每个 require/import 语句中，找到需要引入到 bundle 中的模块代码。 当打包模块时，webpack 使用 enhanced-resolve 来解析文件路径。</p>
<h2>webpack 中的解析规则</h2>
<p>使用 enhanced-resolve，webpack 能解析三种文件路径：</p>
<h3>绝对路径</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'/home/me/file'</span>;

<span class="hljs-keyword">import</span> <span class="hljs-string">'C:\\Users\\me\\file'</span>;
</code></pre><p>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</p>
<h3>相对路径</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'../src/file1'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'./file2'</span>;
</code></pre><p>在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录。在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径。</p>
<h3>模块路径</h3>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-string">'module'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-string">'module/lib/file'</span>;
</code></pre><p>在 resolve.modules 中指定的所有目录中检索模块。 你可以通过配置别名的方式来替换初始模块路径，具体请参照 resolve.alias 配置选项。</p>
<ul>
<li>如果 package 中包含 package.json 文件，那么在 resolve.exportsFields 配置选项中指定的字段会被依次查找，package.json 中的第一个字段会根据 package 导出指南确定 package 中可用的 export。</li>
</ul>
<p>一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。如果路径指向文件：</p>
<ul>
<li>如果文件具有扩展名，则直接将文件打包。</li>
<li>否则，将使用 resolve.extensions 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 .js，.jsx）。</li>
</ul>
<p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p>
<ul>
<li>如果文件夹中包含 package.json 文件，则会根据 resolve.mainFields 配置中的字段顺序查找，并根据 package.json 中的符合配置要求的第一个字段来确定文件路径。</li>
<li>如果不存在 package.json 文件或 resolve.mainFields 没有返回有效路径，则会根据 resolve.mainFiles 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。</li>
<li>然后使用 resolve.extensions 选项，以类似的方式解析文件扩展名。</li>
</ul>
<p>Webpack 会根据构建目标，为这些选项提供合理的默认配置。</p>
<h2>解析 loader</h2>
<p>loader 的解析规则也遵循特定的规范。但是 resolveLoader 配置项可以为 loader 设置独立的解析规则。</p>
<h2>缓存</h2>
<p>每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 watch 模式 下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存。</p>
<p>欲了解更多上述配置信息，请查阅 Resolve API。</p>
<h1>Module Federation</h1>
<h2>动机</h2>
<p>多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。</p>
<p>这通常被称作微前端，但并不仅限于此。</p>
<h6>Live Preview</h6>
<p>Check out this live module federation example on StackBlitz.</p>
<h2>底层概念</h2>
<p>我们区分本地模块和远程模块。本地模块即为普通模块，是当前构建的一部分。远程模块不属于当前构建，并在运行时从所谓的容器加载。</p>
<p>加载远程模块被认为是异步操作。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中。如果没有 chunk 加载操作，就不能使用远程模块。</p>
<p>chunk 的加载操作通常是通过调用 import() 实现的，但也支持像 require.ensure 或 require([...]) 之类的旧语法。</p>
<p>容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。暴露的访问分为两个步骤：</p>
<ol>
<li>加载模块（异步的）</li>
<li>执行模块（同步的）</li>
</ol>
<p>步骤 1 将在 chunk 加载期间完成。步骤 2 将在与其他（本地和远程）的模块交错执行期间完成。这样一来，执行顺序不受模块从本地转换为远程或从远程转为本地的影响。</p>
<p>容器可以嵌套使用，容器可以使用来自其他容器的模块。容器之间也可以循环依赖。</p>
<h2>高级概念</h2>
<p>每个构建都充当一个容器，也可将其他构建作为容器。通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。</p>
<p>共享模块是指既可重写的又可作为向嵌套容器提供重写的模块。它们通常指向每个构建中的相同模块，例如相同的库。</p>
<p>packageName 选项允许通过设置包名来查找所需的版本。默认情况下，它会自动推断模块请求，当想禁用自动推断时，请将 requiredVersion 设置为 false 。</p>
<h2>构建块(Building blocks)</h2>
<h3>ContainerPlugin (low level)</h3>
<p>该插件使用指定的公开模块来创建一个额外的容器入口。</p>
<h3>ContainerReferencePlugin (low level)</h3>
<p>该插件将特定的引用添加到作为外部资源（externals）的容器中，并允许从这些容器中导入远程模块。它还会调用这些容器的 override API 来为它们提供重载。本地的重载（当构建也是一个容器时，通过 <strong>webpack_override</strong> 或 override API）和指定的重载被提供给所有引用的容器。</p>
<h3>ModuleFederationPlugin (high level)</h3>
<p>ModuleFederationPlugin 组合了 ContainerPlugin 和 ContainerReferencePlugin。</p>
<h2>概念目标</h2>
<ul>
<li>它既可以暴露，又可以使用 webpack 支持的任何模块类型</li>
<li>代码块加载应该并行加载所需的所有内容(web:到服务器的单次往返)</li>
<li>从使用者到容器的控制<ul>
<li>重写模块是一种单向操作</li>
<li>同级容器不能重写彼此的模块。</li>
</ul>
</li>
<li>概念适用于独立于环境<ul>
<li>可用于 web、Node.js 等</li>
</ul>
</li>
<li>共享中的相对和绝对请求<ul>
<li>会一直提供，即使不使用</li>
<li>会将相对路径解析到 config.context</li>
<li>默认不会使用 requiredVersion</li>
</ul>
</li>
<li>共享中的模块请求<ul>
<li>只在使用时提供</li>
<li>会匹配构建中所有使用的相等模块请求</li>
<li>将提供所有匹配模块</li>
<li>将从图中这个位置的 package.json 提取 requiredVersion</li>
<li>当你有嵌套的 node_modules 时，可以提供和使用多个不同的版本</li>
</ul>
</li>
<li>共享中尾部带有 / 的模块请求将匹配所有具有这个前缀的模块请求</li>
</ul>
<h2>用例</h2>
<h3>每个页面单独构建</h3>
<p>单页应用的每个页面都是在单独的构建中从容器暴露出来的。主体应用程序(application shell)也是独立构建，会将所有页面作为远程模块来引用。通过这种方式，可以单独部署每个页面。在更新路由或添加新路由时部署主体应用程序。主体应用程序将常用库定义为共享模块，以避免在页面构建中出现重复。</p>
<h3>将组件库作为容器</h3>
<p>许多应用程序共享一个通用的组件库，可以将其构建成暴露所有组件的容器。每个应用程序使用来自组件库容器的组件。可以单独部署对组件库的更改，而不需要重新部署所有应用程序。应用程序自动使用组件库的最新版本。</p>
<h2>动态远程容器</h2>
<p>该容器接口支持 get 和 init 方法。 init 是一个兼容 async 的方法，调用时，只含有一个参数：共享作用域对象(shared scope object)。此对象在远程容器中用作共享作用域，并由 host 提供的模块填充。 可以利用它在运行时动态地将远程容器连接到 host 容器。</p>
<p>init.js</p>
<pre><code class="hljs language-javascript">(<span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-comment">// 初始化共享作用域（shared scope）用提供的已知此构建和所有远程的模块填充它</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">__webpack_init_sharing__</span>(<span class="hljs-string">'default'</span>);
  <span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">window</span>.<span class="hljs-property">someContainer</span>; <span class="hljs-comment">// 或从其他地方获取容器</span>
  <span class="hljs-comment">// 初始化容器 它可能提供共享模块</span>
  <span class="hljs-keyword">await</span> container.<span class="hljs-title function_">init</span>(__webpack_share_scopes__.<span class="hljs-property">default</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-variable language_">module</span> = <span class="hljs-keyword">await</span> container.<span class="hljs-title function_">get</span>(<span class="hljs-string">'./module'</span>);
})();
</code></pre><p>容器尝试提供共享模块，但是如果共享模块已经被使用，则会发出警告，并忽略所提供的共享模块。容器仍能将其作为降级模块。</p>
<p>你可以通过动态加载的方式，提供一个共享模块的不同版本，从而实现 A/B 测试。</p>
<h6>提示</h6>
<p>在尝试动态连接远程容器之前，确保已加载容器。</p>
<p>例子：</p>
<p>init.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadComponent</span>(<span class="hljs-params">scope, <span class="hljs-variable language_">module</span></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">async</span> () =&gt; {
    <span class="hljs-comment">// 初始化共享作用域（shared scope）用提供的已知此构建和所有远程的模块填充它</span>
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">__webpack_init_sharing__</span>(<span class="hljs-string">'default'</span>);
    <span class="hljs-keyword">const</span> container = <span class="hljs-variable language_">window</span>[scope]; <span class="hljs-comment">// 或从其他地方获取容器</span>
    <span class="hljs-comment">// 初始化容器 它可能提供共享模块</span>
    <span class="hljs-keyword">await</span> container.<span class="hljs-title function_">init</span>(__webpack_share_scopes__.<span class="hljs-property">default</span>);
    <span class="hljs-keyword">const</span> factory = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">window</span>[scope].<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">module</span>);
    <span class="hljs-keyword">const</span> <span class="hljs-title class_">Module</span> = <span class="hljs-title function_">factory</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Module</span>;
  };
}

<span class="hljs-title function_">loadComponent</span>(<span class="hljs-string">'abtests'</span>, <span class="hljs-string">'test123'</span>);
</code></pre><p>查看完整实现</p>
<h2>基于 Promise 的动态 Remote</h2>
<p>一般来说，remote 是使用 URL 配置的，示例如下：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'host'</span>,
      <span class="hljs-attr">remotes</span>: {
        <span class="hljs-attr">app1</span>: <span class="hljs-string">'app1@http://localhost:3001/remoteEntry.js'</span>,
      },
    }),
  ],
};
</code></pre><p>但是你也可以向 remote 传递一个 promise，其会在运行时被调用。你应该用任何符合上面描述的 get/init 接口的模块来调用这个 promise。例如，如果你想传递你应该使用哪个版本的联邦模块，你可以通过一个查询参数做以下事情：</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'host'</span>,
      <span class="hljs-attr">remotes</span>: {
        <span class="hljs-attr">app1</span>: <span class="hljs-string">`promise new Promise(resolve =&gt; {
      const urlParams = new URLSearchParams(window.location.search)
      const version = urlParams.get('app1VersionParam')
      // This part depends on how you plan on hosting and versioning your federated modules
      const remoteUrlWithVersion = 'http://localhost:3001/' + version + '/remoteEntry.js'
      const script = document.createElement('script')
      script.src = remoteUrlWithVersion
      script.onload = () =&gt; {
        // the injected script has loaded and is available on window
        // we can now resolve this Promise
        const proxy = {
          get: (request) =&gt; window.app1.get(request),
          init: (arg) =&gt; {
            try {
              return window.app1.init(arg)
            } catch(e) {
              console.log('remote container already initialized')
            }
          }
        }
        resolve(proxy)
      }
      // inject this script with the src set to the versioned remoteEntry.js
      document.head.appendChild(script);
    })
    `</span>,
      },
      <span class="hljs-comment">// ...</span>
    }),
  ],
};
</code></pre><p>请注意当使用该 API 时，你 必须 resolve 一个包含 get/init API 的对象。</p>
<h2>动态 Public Path</h2>
<h3>提供一个 host api 以设置 publicPath</h3>
<p>可以允许 host 在运行时通过公开远程模块的方法来设置远程模块的 publicPath。</p>
<p>当你在 host 域的子路径上挂载独立部署的子应用程序时，这种方法特别有用。</p>
<p>场景：</p>
<p>你在 <a href="https://my-host.com/app/">https://my-host.com/app/</a>* 上有一个 host 应用，并且在 <a href="https://foo-app.com">https://foo-app.com</a> 上有一个子应用。子应用程序也挂载在 host 域上, 因此， <a href="https://foo-app.com">https://foo-app.com</a> 可以通过 <a href="https://my-host.com/app/foo-app">https://my-host.com/app/foo-app</a> 访问，并且 <a href="https://my-host.com/app/foo-app/">https://my-host.com/app/foo-app/</a>* 可以通过代理重定向到 <a href="https://foo-app.com/*%E3%80%82">https://foo-app.com/*。</a></p>
<p>示例：</p>
<p>webpack.config.js (remote)</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">remote</span>: <span class="hljs-string">'./public-path'</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'remote'</span>, <span class="hljs-comment">// 该名称必须与入口名称相匹配</span>
      <span class="hljs-attr">exposes</span>: [<span class="hljs-string">'./public-path'</span>],
      <span class="hljs-comment">// ...</span>
    }),
  ],
};
</code></pre><p>public-path.js (remote)</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">value</span>) {
  __webpack_public_path__ = value;
}
</code></pre><p>src/index.js (host)</p>
<pre><code class="hljs language-ts"><span class="hljs-keyword">const</span> publicPath = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'remote/public-path'</span>);
publicPath.<span class="hljs-title function_">set</span>(<span class="hljs-string">'/your-public-path'</span>);

<span class="hljs-comment">//bootstrap app  e.g. import('./bootstrap.js')</span>
</code></pre><h3>Infer publicPath from script</h3>
<p>One could infer the publicPath from the script tag from document.currentScript.src and set it with the <strong>webpack_public_path</strong> module variable at runtime.</p>
<p>示例：</p>
<p>webpack.config.js (remote)</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">remote</span>: <span class="hljs-string">'./setup-public-path'</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
      <span class="hljs-attr">name</span>: <span class="hljs-string">'remote'</span>, <span class="hljs-comment">// 该名称必须与入口名称相匹配</span>
      <span class="hljs-comment">// ...</span>
    }),
  ],
};
</code></pre><p>setup-public-path.js (remote)</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 使用你自己的逻辑派生 publicPath，并使用 __webpack_public_path__ API 设置它</span>
__webpack_public_path__ = <span class="hljs-variable language_">document</span>.<span class="hljs-property">currentScript</span>.<span class="hljs-property">src</span> + <span class="hljs-string">'/../'</span>;
</code></pre><h6>提示</h6>
<p>output.publicPath 配置项也可设置为 'auto'，它将为你自动决定一个 publicPath。</p>
<h2>故障排除</h2>
<h3>Uncaught Error: Shared module is not available for eager consumption</h3>
<p>应用程序正急切地执行一个作为全局主机运行的应用程序。有如下选项可供选择:</p>
<p>你可以在模块联邦的高级 API 中将依赖设置为即时依赖，此 API 不会将模块放在异步 chunk 中，而是同步地提供它们。这使得我们在初始块中可以直接使用这些共享模块。但是要注意，由于所有提供的和降级模块是要异步下载的，因此，建议只在应用程序的某个地方提供它，例如 shell。</p>
<p>我们强烈建议使用异步边界(asynchronous boundary)。它将把初始化代码分离成更大的块，以避免任何额外的开销，以提高总体性能。</p>
<p>例如，你的入口看起来是这样的：</p>
<p>index.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./App'</span>;
<span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'root'</span>));
</code></pre><p>让我们创建 bootstrap.js 文件，并将入口文件的内容放到里面，然后将 bootstrap 引入到入口文件中:</p>
<p>index.js</p>
<pre><code class="hljs language-diff"><span class="hljs-addition">+ import('./bootstrap');</span>
<span class="hljs-deletion">- import React from 'react';</span>
<span class="hljs-deletion">- import ReactDOM from 'react-dom';</span>
<span class="hljs-deletion">- import App from './App';</span>
<span class="hljs-deletion">- ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span>
</code></pre><p>bootstrap.js</p>
<pre><code class="hljs language-diff"><span class="hljs-addition">+ import React from 'react';</span>
<span class="hljs-addition">+ import ReactDOM from 'react-dom';</span>
<span class="hljs-addition">+ import App from './App';</span>
<span class="hljs-addition">+ ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</span>
</code></pre><p>这种方法有效，但存在局限性或缺点。</p>
<p>通过 ModuleFederationPlugin 将依赖的 eager 属性设置为 true</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-comment">// ...</span>
<span class="hljs-keyword">new</span> <span class="hljs-title class_">ModuleFederationPlugin</span>({
  <span class="hljs-attr">shared</span>: {
    ...deps,
    <span class="hljs-attr">react</span>: {
      <span class="hljs-attr">eager</span>: <span class="hljs-literal">true</span>,
    },
  },
});
</code></pre><h3>Uncaught Error: Module "./Button" does not exist in container.</h3>
<p>错误提示中可能不会显示 "./Button"，但是信息看起来差不多。这个问题通常会出现在将 webpack beta.16 升级到 webpack beta.17 中。</p>
<p>在 ModuleFederationPlugin 里，更改 exposes:</p>
<pre><code class="hljs language-diff">new ModuleFederationPlugin({
  exposes: {
<span class="hljs-deletion">-   'Button': './src/Button'</span>
<span class="hljs-addition">+   './Button':'./src/Button'</span>
  }
});
</code></pre><h3>Uncaught TypeError: fn is not a function</h3>
<p>此处错误可能是丢失了远程容器，请确保在使用前添加它。 如果已为试图使用远程服务器的容器加载了容器，但仍然看到此错误，则需将主机容器的远程容器文件也添加到 HTML 中。</p>
<h3>来自多个 remote 的模块之间的冲突</h3>
<p>如果你想从不同的 remote 中加载多个模块，建议为你的远程构建设置 output.uniqueName 以避免多个 webpack 运行时之间的冲突。 If you're going to load multiple modules from different remotes, it's advised to set the output.uniqueName option for your remote builds to avoid collisions between multiple webpack runtimes.</p>
<h1>依赖图(dependency graph)</h1>
<p>每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在 依赖关系。这使得 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把它们作为 依赖 提供给应用程序。</p>
<p>当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。 从 入口 开始，webpack 会递归的构建一个 依赖关系图，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 bundle —— 通常只有一个 —— 可由浏览器加载。</p>
<h6>提示</h6>
<p>对于 HTTP/1.1 的应用程序来说，由 webpack 构建的 bundle 非常强大。当浏览器发起请求时，它能最大程度的减少应用的等待时间。而对于 HTTP/2 来说，你还可以使用代码分离进行进一步优化。</p>
<h1>target</h1>
<p>由于 JavaScript 既可以编写服务端代码也可以编写浏览器代码，所以 webpack 提供了多种部署 target，你可以在 webpack 的配置选项中进行设置。</p>
<h6>警告</h6>
<p>webpack 的 target 属性，不要和 output.libraryTarget 属性混淆。有关 output 属性的更多信息，请参阅 output 指南</p>
<h2>用法</h2>
<p>想设置 target 属性，只需在 webpack 配置中设置 target 字段：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">target</span>: <span class="hljs-string">'node'</span>,
};
</code></pre><p>在上述示例中，target 设置为 node，webpack 将在类 Node.js 环境编译代码。(使用 Node.js 的 require 加载 chunk，而不加载任何内置模块，如 fs 或 path)。</p>
<p>每个 target 都包含各种 deployment（部署）/environment（环境）特定的附加项，以满足其需求。具体请参阅 target 可用值。</p>
<h6>TODO</h6>
<p>后续会进一步扩展受欢迎的 target。</p>
<h2>多 target</h2>
<p>虽然 webpack 不支持 向 target 属性传入多个字符串，但是可以通过设置两个独立配置，来构建对 library 进行同构：</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);
<span class="hljs-keyword">const</span> serverConfig = {
  <span class="hljs-attr">target</span>: <span class="hljs-string">'node'</span>,
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'lib.node.js'</span>,
  },
  <span class="hljs-comment">//…</span>
};

<span class="hljs-keyword">const</span> clientConfig = {
  <span class="hljs-attr">target</span>: <span class="hljs-string">'web'</span>, <span class="hljs-comment">// &lt;=== 默认为 'web'，可省略</span>
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">'dist'</span>),
    <span class="hljs-attr">filename</span>: <span class="hljs-string">'lib.js'</span>,
  },
  <span class="hljs-comment">//…</span>
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = [serverConfig, clientConfig];
</code></pre><p>上述示例中，将会在 dist 文件夹下创建 lib.js 和 lib.node.js 文件。</p>
<h1>manifest</h1>
<p>在使用 webpack 构建的典型应用程序或站点中，有三种主要的代码类型：</p>
<ol>
<li>你或你的团队编写的源码。</li>
<li>你的源码会依赖的任何第三方的 library 或 "vendor" 代码。</li>
<li>webpack 的 runtime 和 manifest，管理所有模块的交互。</li>
</ol>
<p>本文将重点介绍这三个部分中的最后部分：runtime 和 manifest，特别是 manifest。</p>
<h2>runtime</h2>
<p>runtime，以及伴随的 manifest 数据，主要是指：在浏览器运行过程中，webpack 用来连接模块化应用程序所需的所有代码。它包含：在模块交互时，连接模块所需的加载和解析逻辑。包括：已经加载到浏览器中的连接模块逻辑，以及尚未加载模块的延迟加载逻辑。</p>
<h2>manifest</h2>
<p>一旦你的应用在浏览器中以 index.html 文件的形式被打开，一些 bundle 和应用需要的各种资源都需要用某种方式被加载与链接起来。在经过打包、压缩、为延迟加载而拆分为细小的 chunk 这些 webpack 优化 之后，你精心安排的 /src 目录的文件结构都已经不再存在。所以 webpack 如何管理所有所需模块之间的交互呢？这就是 manifest 数据用途的由来……</p>
<p>当 compiler 开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 "manifest"，当完成打包并发送到浏览器时，runtime 会通过 manifest 来解析和加载模块。无论你选择哪种 模块语法，那些 import 或 require 语句现在都已经转换为 <strong>webpack_require</strong> 方法，此方法指向模块标识符(module identifier)。通过使用 manifest 中的数据，runtime 将能够检索这些标识符，找出每个标识符背后对应的模块。</p>
<h2>问题</h2>
<p>所以，现在你应该对 webpack 在幕后工作有一点了解。“但是，这对我有什么影响呢？”，你可能会问。答案是大多数情况下没有。runtime 做完成这些工作：一旦你的应用程序加载到浏览器中，使用 manifest，然后所有内容将展现出魔幻般运行结果。然而，如果你决定通过使用浏览器缓存来改善项目的性能，理解这一过程将突然变得极为重要。</p>
<p>通过使用内容散列(content hash)作为 bundle 文件的名称，这样在文件内容修改时，会计算出新的 hash，浏览器会使用新的名称加载文件，从而使缓存无效。一旦你开始这样做，你会立即注意到一些有趣的行为。即使某些内容明显没有修改，某些 hash 还是会改变。这是因为，注入的 runtime 和 manifest 在每次构建后都会发生变化。</p>
<p>查看 管理输出 指南的 manifest 部分，了解如何提取 manifest，并阅读下面的指南，以了解更多长效缓存错综复杂之处。</p>
<h1>模块热替换(hot module replacement)</h1>
<p>模块热替换(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除 模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p>
<ul>
<li>保留在完全重新加载页面期间丢失的应用程序状态。</li>
<li>只更新变更内容，以节省宝贵的开发时间。</li>
<li>在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li>
</ul>
<h2>这一切是如何运行的？</h2>
<p>让我们从一些不同的角度观察，以了解 HMR 的工作原理……</p>
<h3>在应用程序中</h3>
<p>通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：</p>
<ol>
<li>应用程序要求 HMR runtime 检查更新。</li>
<li>HMR runtime 异步地下载更新，然后通知应用程序。</li>
<li>应用程序要求 HMR runtime 应用更新。</li>
<li>HMR runtime 同步地应用更新。</li>
</ol>
<p>你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。</p>
<h3>在 compiler 中</h3>
<p>除了普通资源，compiler 需要发出 "update"，将之前的版本更新到新的版本。"update" 由两部分组成：</p>
<ol>
<li>更新后的 manifest (JSON)</li>
<li>一个或多个 updated chunk (JavaScript)</li>
</ol>
<p>manifest 包括新的 compilation hash 和所有的 updated chunk 列表。每个 chunk 都包含着全部更新模块的最新代码（或一个 flag 用于表明此模块需要被移除）。</p>
<p>compiler 会确保在这些构建之间的模块 ID 和 chunk ID 保持一致。通常将这些 ID 存储在内存中（例如，使用 webpack-dev-server 时），但是也可能会将它们存储在一个 JSON 文件中。</p>
<h3>在模块中</h3>
<p>HMR 是可选功能，只会影响包含 HMR 代码的模块。举个例子，通过 style-loader 为 style 追加补丁。为了运行追加补丁，style-loader 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。</p>
<p>类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。然而在多数情况下，不需要在每个模块中强行写入 HMR 代码。如果一个模块没有 HMR 处理函数，更新就会冒泡(bubble up)。这意味着某个单独处理函数能够更新整个模块树。如果在模块树的一个单独模块被更新，那么整组依赖模块都会被重新加载。</p>
<p>有关 module.hot 接口的详细信息，请查看 HMR API 页面。</p>
<h3>在 runtime 中</h3>
<p>这件事情比较有技术性……如果你对其内部不感兴趣，可以随时跳到 HMR API 页面 或 HMR 指南。</p>
<p>对于模块系统运行时(module system runtime)，会发出额外代码，来跟踪模块 parents 和 children 关系。在管理方面，runtime 支持两个方法 check 和 apply。</p>
<p>check 方法，发送一个 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，会将 updated chunk 列表与当前的 loaded chunk 列表进行比较。每个 loaded chunk 都会下载相应的 updated chunk。当所有更新 chunk 完成下载，runtime 就会切换到 ready 状态。</p>
<p>apply 方法，将所有 updated module 标记为无效。对于每个无效 module，都需要在模块中有一个 update handler，或者在此模块的父级模块中有 update handler。否则，会进行无效标记冒泡，并且父级也会被标记为无效。继续每个冒泡，直到到达应用程序入口起点，或者到达带有 update handler 的 module（以最先到达为准，冒泡停止）。如果它从入口起点开始冒泡，则此过程失败。</p>
<p>之后，所有无效 module 都会被（通过 dispose handler）处理和解除加载。然后更新当前 hash，并且调用所有 accept handler。runtime 切换回 idle 状态，一切照常继续。</p>
<h2>起步</h2>
<p>在开发环境，可以将 HMR 作为 LiveReload 的替代。webpack-dev-server 支持 hot 模式，在试图重新加载整个页面之前，hot 模式会尝试使用 HMR 来更新。更多细节请查看 模块热替换 指南。</p>
<h6>提示</h6>
<p>与许多其他功能一样，webpack 的强大之处在于它的可定制化。取决于特定项目需求，会有 许多方式 来配置 HMR。然而，对于多数项目的实现目的来说，webpack-dev-server 都能够很好适应，可以帮助你在项目中快速应用 HMR。</p>
<h1>为什么选择 webpack</h1>
<p>想要理解为什么要使用 webpack，我们先回顾下历史，在打包工具出现之前，我们是如何在 web 中使用 JavaScript 的。</p>
<p>在浏览器中运行 JavaScript 有两种方法。第一种方式，引用一些脚本来存放每个功能；此解决方案很难扩展，因为加载太多脚本会导致网络瓶颈。第二种方式，使用一个包含所有项目代码的大型 .js 文件，但是这会导致作用域、文件大小、可读性和可维护性方面的问题。</p>
<h2>立即调用函数表达式(IIFE) - Immediately invoked function expressions</h2>
<p>IIFE 解决大型项目的作用域问题；当脚本文件被封装在 IIFE 内部时，你可以安全地拼接或安全地组合所有文件，而不必担心作用域冲突。</p>
<p>IIFE 使用方式产生出 Make, Gulp, Grunt, Broccoli 或 Brunch 等工具。这些工具称为任务执行器，它们将所有项目文件拼接在一起。</p>
<p>但是，修改一个文件意味着必须重新构建整个文件。拼接可以做到很容易地跨文件重用脚本，但是却使构建结果的优化变得更加困难。如何判断代码是否实际被使用？</p>
<p>即使你只用到 lodash 中的某个函数，也必须在构建结果中加入整个库，然后将它们压缩在一起。如何 treeshake 代码依赖？难以大规模地实现延迟加载代码块，这需要开发人员手动地进行大量工作。</p>
<h2>感谢 Node.js，JavaScript 模块诞生了</h2>
<p>Node.js 是一个 JavaScript 运行时，可以在浏览器环境之外的计算机和服务器中使用。webpack 运行在 Node.js 中。</p>
<p>当 Node.js 发布时，一个新的时代开始了，它带来了新的挑战。既然不是在浏览器中运行 JavaScript，现在已经没有了可以添加到浏览器中的 html 文件和 script 标签。那么 Node.js 应用程序要如何加载新的代码 chunk 呢？</p>
<p>CommonJS 问世并引入了 require 机制，它允许你在当前文件中加载和使用某个模块。导入需要的每个模块，这一开箱即用的功能，帮助我们解决了作用域问题。</p>
<h2>npm + Node.js + modules - 大规模分发模块</h2>
<p>JavaScript 已经成为一种语言、一个平台和一种快速开发和创建快速应用程序的方式，接管了整个 JavaScript 世界。</p>
<p>但 CommonJS 没有浏览器支持。没有 live binding(实时绑定)。循环引用存在问题。同步执行的模块解析加载器速度很慢。虽然 CommonJS 是 Node.js 项目的绝佳解决方案，但浏览器不支持模块，因而产生了 Browserify, RequireJS 和 SystemJS 等打包工具，允许我们编写能够在浏览器中运行的 CommonJS 模块。</p>
<h2>ESM - ECMAScript 模块</h2>
<p>来自 Web 项目的好消息是，模块正在成为 ECMAScript 标准的官方功能。然而，浏览器支持不完整，版本迭代速度也不够快，目前还是推荐上面那些早期模块实现。</p>
<h2>依赖自动收集</h2>
<p>传统的任务构建工具基于 Google 的 Closure 编译器都要求你手动在顶部声明所有的依赖。然而像 webpack 一类的打包工具自动构建并基于你所引用或导出的内容推断出依赖的图谱。这个特性与其它的如插件 and 加载器一道让开发者的体验更好。</p>
<h2>看起来都不是很好……</h2>
<p>是否可以有一种方式，不仅可以让我们编写模块，而且还支持任何模块格式（至少在我们到达 ESM 之前），并且可以同时处理资源和资产？</p>
<p>这就是 webpack 存在的原因。它是一个工具，可以打包你的 JavaScript 应用程序（支持 ESM 和 CommonJS），可以扩展为支持许多不同的静态资源，例如：images, fonts 和 stylesheets。</p>
<p>webpack 关心性能和加载时间；它始终在改进或添加新功能，例如：异步地加载 chunk 和预取，以便为你的项目和用户提供最佳体验。</p>
<h1>揭示内部原理</h1>
<blockquote>
<p>此章节描述 webpack 内部实现，对于插件开发人员可能会提供帮助</p>
</blockquote>
<p>打包，是指处理某些文件并将其输出为其他文件的能力。</p>
<p>但是，在输入和输出之间，还包括有 模块, 入口起点, chunk, chunk 组和许多其他中间部分。</p>
<h2>主要部分</h2>
<p>项目中使用的每个文件都是一个 模块</p>
<p>./index.js</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> app <span class="hljs-keyword">from</span> <span class="hljs-string">'./app.js'</span>;
</code></pre><p>./app.js</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-string">'the app'</span>;
</code></pre><p>通过互相引用，这些模块会形成一个图(ModuleGraph)数据结构。</p>
<p>在打包过程中，模块会被合并成 chunk。 chunk 合并成 chunk 组，并形成一个通过模块互相连接的图(ModuleGraph)。 那么如何通过以上来描述一个入口起点：在其内部，会创建一个只有一个 chunk 的 chunk 组。</p>
<p>./webpack.config.js</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./index.js'</span>,
};
</code></pre><p>这会创建出一个名为 main 的 chunk 组（main 是入口起点的默认名称）。 此 chunk 组包含 ./index.js 模块。随着 parser 处理 ./index.js 内部的 import 时， 新模块就会被添加到此 chunk 中。</p>
<p>另外的一个示例：</p>
<p>./webpack.config.js</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: {
    <span class="hljs-attr">home</span>: <span class="hljs-string">'./home.js'</span>,
    <span class="hljs-attr">about</span>: <span class="hljs-string">'./about.js'</span>,
  },
};
</code></pre><p>这会创建出两个名为 home 和 about 的 chunk 组。 每个 chunk 组都有一个包含一个模块的 chunk：./home.js 对应 home，./about.js 对应 about</p>
<blockquote>
<p>一个 chunk 组中可能有多个 chunk。例如，SplitChunksPlugin 会将一个 chunk 组拆分为一个或多个 chunk。</p>
</blockquote>
<h2>chunk</h2>
<p>chunk 有两种形式：</p>
<ul>
<li>initial(初始化) 是入口起点的 main chunk。此 chunk 包含为入口起点指定的所有模块及其依赖项。</li>
<li>non-initial 是可以延迟加载的块。可能会出现在使用 动态导入(dynamic imports) 或者 SplitChunksPlugin 时。</li>
</ul>
<p>每个 chunk 都有对应的 asset(资源)。资源，是指输出文件（即打包结果）。</p>
<p>webpack.config.js</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">entry</span>: <span class="hljs-string">'./src/index.jsx'</span>,
};
</code></pre><p>./src/index.jsx</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'react-dom'</span>;

<span class="hljs-keyword">import</span>(<span class="hljs-string">'./app.jsx'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">App</span>) =&gt;</span> {
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, root);
});
</code></pre><p>这会创建出一个名为 main 的 initial chunk。其中包含：</p>
<ul>
<li>./src/index.jsx</li>
<li>react</li>
<li>react-dom</li>
</ul>
<p>以及除 ./app.jsx 外的所有依赖</p>
<p>然后会为 ./app.jsx 创建 non-initial chunk，这是因为 ./app.jsx 是动态导入的。</p>
<p>Output:</p>
<ul>
<li>/dist/main.js - 一个 initial chunk</li>
<li>/dist/394.js - non-initial chunk</li>
</ul>
<p>默认情况下，这些 non-initial chunk 没有名称，因此会使用唯一 ID 来替代名称。 在使用动态导入时，我们可以通过使用 magic comment(魔术注释) 来显式指定 chunk 名称：</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span>(
  <span class="hljs-comment">/* webpackChunkName: "app" */</span>
  <span class="hljs-string">'./app.jsx'</span>
).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">App</span>) =&gt;</span> {
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, root);
});
</code></pre><p>Output:</p>
<ul>
<li>/dist/main.js - 一个 initial chunk</li>
<li>/dist/app.js - non-initial chunk</li>
</ul>
<h2>output(输出)</h2>
<p>输出文件的名称会受配置中的两个字段的影响：</p>
<ul>
<li>output.filename - 用于 initial chunk 文件</li>
<li>output.chunkFilename - 用于 non-initial chunk 文件</li>
<li>在某些情况下，使用 initial 和 non-initial 的 chunk 时，可以使用 output.filename。</li>
</ul>
<p>这些字段中会有一些 占位符。常用的占位符如下：</p>
<ul>
<li>[id] - chunk id（例如 [id].js -&gt; 485.js）</li>
<li>[name] - chunk name（例如 [name].js -&gt; app.js）。如果 chunk 没有名称，则会使用其 id 作为名称</li>
<li>[contenthash] - 输出文件内容的 md4-hash（例如 [contenthash].js -&gt; 4ea6ff1de66c537eb9b2.js）</li>
</ul>
</div>
      </div>
      <div id="right">
        <div id="right-top">
          <div id="right-top-header">
            <ul>
              <li><button>代码</button></li>
              <li><button>总结</button></li>
              <li><button>评论</button></li>
            </ul>
          </div>
          <div id="right-top-content">
            <div id="code-container"></div>
          </div>
        </div>
        <div id="right-bottom">
          <div>bb</div>
        </div>
      </div>
    </div>
    <script type="module" src="/blog/index.js"></script>

</body></html>